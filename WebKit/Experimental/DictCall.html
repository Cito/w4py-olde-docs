<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.2.8: http://docutils.sourceforge.net/" />
<title>DictCall</title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document" id="dictcall">
<h1 class="title">DictCall</h1>
<p>DictCall primarily exports the function <cite>dictCall</cite>, which may
raise the exceptions <cite>NotFound</cite> or <cite>Invalid</cite> (both of which
are inherited from <cite>DictCallError</cite>.</p>
<!-- include: dictCall -->
<a class="target" id="id1" name="id1"></a><div class="topic">
<p class="topic-title"><tt class="literal"><span class="pre">dictCall(func,</span> <span class="pre">d)</span></tt>:</p>
<p>Calls the function <cite>func</cite> with the information from dictionary
<cite>d</cite>.</p>
<p><cite>d</cite> is expected to be a dictionary of strings, possibly with
lists of strings for some keys, as might be generated by the
<cite>cgi</cite> module.  <cite>dictCall</cite> will match the keys of the dictionary
with the arguments of the function.</p>
<p>The function can provide type information, so that the input is
verified and coerced in some fashion.  However, type information
is not required.</p>
<p><strong>Defining Parameter Types</strong></p>
<p>There are two ways of providing type information: by the parameter
names themselves, or in the docstring.</p>
<p>Parameter names can be typed by appending the types to the name,
like <tt class="literal"><span class="pre">var_int</span></tt>.  The dictionary will still be searched for a
variable <tt class="literal"><span class="pre">var</span></tt>, but then it will be converted into an int.
However, note that your parameter is still named var_int!  This
can be annoying.</p>
<p>Instead you can put the type information in the docstring.  You
should begin this information with a line like:</p>
<pre class="literal-block">
call types:
</pre>
<p>on a line by itself.  Later lines should be of the format:</p>
<pre class="literal-block">
var: dict, int
</pre>
<p>where <tt class="literal"><span class="pre">dict,</span> <span class="pre">int</span></tt> equivalent to var_dict_int (types are
described later).  You end this section of information with a
blank line.  Indentation is not significant.  Variables that are
simply strings may be omited.</p>
<p>You can also put the information in a function attribute, like:</p>
<pre class="literal-block">
def myFunc(a, b, c):
    pass
myFunc.callTypes={'a': 'dict,int', 'c': 'int'}
</pre>
<p>This is equivalent to <tt class="literal"><span class="pre">myFunc(a_dict_int,</span> <span class="pre">b,</span> <span class="pre">c_int)</span></tt>. Note
Python 2.3 you can use:</p>
<pre class="literal-block">
myFunc.callTypes=dict(a='dict,int', c='int')
</pre>
<p><strong>Parameter Types</strong></p>
<p>The basic types, besides the implicit string type, are <tt class="literal"><span class="pre">int</span></tt> and
<tt class="literal"><span class="pre">float</span></tt>.</p>
<p>In addition to these types there are three compound types:</p>
<dl>
<dt><tt class="literal"><span class="pre">set</span></tt>:</dt>
<dd><p class="first">Sets are actually returned as lists, but they are not
generally ordered.  When a dictionary is passed in like
<tt class="literal"><span class="pre">{'var':</span> <span class="pre">['a',</span> <span class="pre">'b']}</span></tt>, this returns <tt class="literal"><span class="pre">['a',</span> <span class="pre">'b']</span></tt> (it's
Invalid if you don't indicate that it's a set).  It also
promotes non-lists to a list, and if nothing is present
returns the empty list (i.e., <tt class="literal"><span class="pre">{'var':</span> <span class="pre">'a'}</span></tt> returns
<tt class="literal"><span class="pre">['a']</span></tt>, and <tt class="literal"><span class="pre">{}</span></tt> returns <tt class="literal"><span class="pre">[]</span></tt>).</p>
<p class="last">Sets can be used with <tt class="literal"><span class="pre">int</span></tt> and <tt class="literal"><span class="pre">float</span></tt>, i.e., a type
of <tt class="literal"><span class="pre">set,</span> <span class="pre">int</span></tt> will return a list of integers.  You cannot
put a <tt class="literal"><span class="pre">dict</span></tt> or <tt class="literal"><span class="pre">list</span></tt> inside a set, though a set can
go inside them.</p>
</dd>
<dt><tt class="literal"><span class="pre">dict</span></tt>:</dt>
<dd><p class="first">A dictionary takes keys of the form <tt class="literal"><span class="pre">var1:key</span></tt> and
turns them into nested dictionaries.  So with a type
dict, <tt class="literal"><span class="pre">{'var:a':</span> <span class="pre">'apple',</span> <span class="pre">'var:b':</span> <span class="pre">'banana'}</span></tt> will
return <tt class="literal"><span class="pre">{'a':</span> <span class="pre">'apple',</span> <span class="pre">'b':</span> <span class="pre">'banana'}</span></tt>.</p>
<p class="last">Dict can be nested, so that keys like <tt class="literal"><span class="pre">var1:key1:key2</span></tt>
are possible, and can also be nested with <tt class="literal"><span class="pre">list</span></tt> and
contain <tt class="literal"><span class="pre">set</span></tt>, <tt class="literal"><span class="pre">int</span></tt>, or <tt class="literal"><span class="pre">float</span></tt>.</p>
</dd>
<dt><tt class="literal"><span class="pre">list</span></tt>:</dt>
<dd>Essentially the same as dict, only it uses the keys only
for ordering, and expects those keys to be integers.
So <tt class="literal"><span class="pre">{'var:1':</span> <span class="pre">'first',</span> <span class="pre">'var:2':</span> <span class="pre">'second'}</span></tt> returns
<tt class="literal"><span class="pre">['first',</span> <span class="pre">'second']</span></tt>.</dd>
</dl>
<p><strong>Using Types Together</strong></p>
<p>If you are, for instance, collecting a list of first and
last names, you can use compound types to manage the fields.
Generate the form like:</p>
<pre class="literal-block">
for i in range(len(names)):
    self.write('&lt;input type=&quot;text&quot; name=&quot;names:%i:fname&quot; value=&quot;%s&quot;&gt;'
               % (i, htmlEncode(names[i]['fname'])))
    self.write('&lt;input type=&quot;text&quot; name=&quot;names:%i:lname&quot; value=&quot;%s&quot;&gt;'
               % (i, htmlEncode(names[i]['fname'])))
</pre>
<p>Then the method that accepts the form looks like:</p>
<pre class="literal-block">
def saveNames(self, names_list_dict)
</pre>
<p><tt class="literal"><span class="pre">names_list_dict</span></tt> will look like
<tt class="literal"><span class="pre">[{'fname':</span> <span class="pre">...,</span> <span class="pre">'lname':</span> <span class="pre">...},</span> <span class="pre">...]</span></tt></p>
</div>
<a class="target" id="specdict" name="specdict"></a><div class="topic">
<p class="topic-title"><tt class="literal"><span class="pre">specDict(func)</span></tt>:</p>
<p>Returns a dictionary that contains whatever type specification
there is for the function.</p>
<p>That dictionary has a key for each value expected or allowed in
the request dictionary -- essentially a key for each argument
variable.  For each key there's another dictionary.  There's keys
<tt class="literal"><span class="pre">targetName</span></tt> and <tt class="literal"><span class="pre">type</span></tt>, where targetName gives the variable
name in the function definition (which may contain type
information embedded, e.g.  var1_int would be considered the
variable <tt class="literal"><span class="pre">&quot;var1&quot;</span></tt> with a type <tt class="literal"><span class="pre">[&quot;int&quot;]</span></tt> and a targetName
<tt class="literal"><span class="pre">&quot;var1_int&quot;</span></tt>.  Also has the key <tt class="literal"><span class="pre">default</span></tt> which is a boolean,
whether this key has a default value.</p>
<p>The presence of the key <tt class="literal"><span class="pre">**</span></tt> means that extra keyword arguments
are allowed (always as strings, unparsed).</p>
</div>
</div>
</body>
</html>
