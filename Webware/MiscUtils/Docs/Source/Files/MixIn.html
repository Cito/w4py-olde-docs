<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>MiscUtils/MixIn.py</title>
<!--css-->

<style type="text/css">
<!--
body{ background: #EEF;
font-family: Verdana, Arial, Helvetica, sans-serif;
font-size: 10pt;
padding: 3pt; }
.PY_KEYWORD{ color: #00C; font-weight: bold; }
.PY_COMMENT{ color: #008; }
.PY_PARAMETER{ color: #C00; }
.PY_IDENTIFIER{ color: #C00; font-weight: bold; }
.PY_STRING{ color: #080; }
-->
</style>
</head>
<body>
<!--header-->

<!--script-->
<pre><span class="PY_KEYWORD">from</span> types <span class="PY_KEYWORD">import</span> MethodType


<span class="PY_KEYWORD">def</span> MixIn(pyClass, mixInClass, makeAncestor=False, mixInSuperMethods=False):
    <span class="PY_STRING">"""Mixes in the attributes of the mixInClass into the pyClass.

    These attributes are typically methods (but don't have to be).
    Note that private attributes, denoted by a double underscore,
    are not mixed in. Collisions are resolved by the mixInClass'
    attribute overwriting the pyClass'. This gives mix-ins the power
    to override the behavior of the pyClass.

    After using MixIn(), instances of the pyClass will respond to
    the messages of the mixInClass.

    An assertion fails if you try to mix in a class with itself.

    The pyClass will be given a new attribute mixInsForCLASSNAME
    which is a list of all mixInClass' that have ever been installed,
    in the order they were installed. You may find this useful
    for inspection and debugging.

    You are advised to install your mix-ins at the start up
    of your program, prior to the creation of any objects.
    This approach will result in less headaches. But like most things
    in Python, you're free to do whatever you're willing to live with. :-)

    There is a bitchin' article in the Linux Journal, April 2001,
    "Using Mix-ins with Python" by Chuck Esterbrook,
    which gives a thorough treatment of this topic.

    An example, that resides in Webware, is MiddleKit.Core.ModelUser.py,
    which install mix-ins for SQL adapters. Search for "MixIn(".

    If makeAncestor is 1, then a different technique is employed:
    the mixInClass is made the first base class of the pyClass.
    You probably don't need to use this and if you do, be aware that your
    mix-in can no longer override attributes/methods in pyClass.

    If mixInSuperMethods is 1, then support will be enabled for you to
    be able to call the original or "parent" method from the mixed-in method.
    This is done like so:

        class MyMixInClass(object):
        def foo(self):
            MyMixInClass.mixInSuperFoo(self) # call the original method
            # now do whatever you want

    """</span>
    <span class="PY_KEYWORD">assert</span> mixInClass <span class="PY_KEYWORD">is</span> <span class="PY_KEYWORD">not</span> pyClass, (
        <span class="PY_STRING">'mixInClass = %r, pyClass = %r'</span> % (mixInClass, pyClass))
    <span class="PY_KEYWORD">if</span> makeAncestor:
        <span class="PY_KEYWORD">if</span> mixInClass <span class="PY_KEYWORD">not</span> <span class="PY_KEYWORD">in</span> pyClass.__bases__:
            pyClass.__bases__ = (mixInClass,) + pyClass.__bases__
    <span class="PY_KEYWORD">else</span>:
        <span class="PY_COMMENT"># Recursively traverse the mix-in ancestor classes in order</span>
        <span class="PY_COMMENT"># to support inheritance</span>
        <span class="PY_KEYWORD">for</span> baseClass <span class="PY_KEYWORD">in</span> reversed(mixInClass.__bases__):
            MixIn(pyClass, baseClass)

        <span class="PY_COMMENT"># Track the mix-ins made for a particular class</span>
        attrName = <span class="PY_STRING">'mixInsFor'</span> + pyClass.__name__
        mixIns = getattr(pyClass, attrName, None)
        <span class="PY_KEYWORD">if</span> mixIns <span class="PY_KEYWORD">is</span> None:
            mixIns = []
            setattr(pyClass, attrName, mixIns)

        <span class="PY_COMMENT"># Record our deed for future inspection</span>
        mixIns.append(mixInClass)

        <span class="PY_COMMENT"># Install the mix-in methods into the class</span>
        <span class="PY_KEYWORD">for</span> name <span class="PY_KEYWORD">in</span> dir(mixInClass):
            <span class="PY_COMMENT"># skip private members, but not __repr__ et al:</span>
            <span class="PY_KEYWORD">if</span> name.startswith(<span class="PY_STRING">'__'</span>):
                <span class="PY_KEYWORD">if</span> <span class="PY_KEYWORD">not</span> name.endswith(<span class="PY_STRING">'__'</span>):
                    <span class="PY_KEYWORD">continue</span> <span class="PY_COMMENT"># private</span>
                member = getattr(mixInClass, name)
                <span class="PY_KEYWORD">if</span> <span class="PY_KEYWORD">not</span> isinstance(member, MethodType):
                    <span class="PY_KEYWORD">continue</span> <span class="PY_COMMENT"># built in or descriptor</span>
            <span class="PY_KEYWORD">else</span>:
                member = getattr(mixInClass, name)
            <span class="PY_KEYWORD">if</span> isinstance(member, MethodType):
                <span class="PY_KEYWORD">if</span> mixInSuperMethods:
                    <span class="PY_KEYWORD">if</span> hasattr(pyClass, name):
                        origmember = getattr(pyClass, name)
                        setattr(mixInClass, <span class="PY_STRING">'mixInSuper'</span>
                            + name[0].upper() + name[1:], origmember)
                member = member.im_func
            setattr(pyClass, name, member)
</pre>
<!--footer-->

</body>
</html>
