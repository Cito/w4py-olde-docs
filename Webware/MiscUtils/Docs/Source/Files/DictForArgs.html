<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>MiscUtils/DictForArgs.py</title>
<!--css-->

<style type="text/css">
<!--
body{ background: #EEF;
font-family: Verdana, Arial, Helvetica, sans-serif;
font-size: 10pt;
padding: 3pt; }
.PY_KEYWORD{ color: #00C; font-weight: bold; }
.PY_COMMENT{ color: #008; }
.PY_PARAMETER{ color: #C00; }
.PY_IDENTIFIER{ color: #C00; font-weight: bold; }
.PY_STRING{ color: #080; }
-->
</style>
</head>
<body>
<!--header-->

<!--script-->
<pre><span class="PY_STRING">"""DictForArgs.py

See the doc string for the DictForArgs() function.

Also, there is a test suite in Tests/TestDictForArgs.py

"""</span>


<span class="PY_KEYWORD">import</span> re


<span class="PY_KEYWORD">class</span> DictForArgsError(Exception):
    <span class="PY_STRING">"""Error when building dictionary from arguments."""</span>


<span class="PY_KEYWORD">def</span> _SyntaxError(s):
    <span class="PY_KEYWORD">raise</span> DictForArgsError(<span class="PY_STRING">'Syntax error: %r'</span> % s)


_nameRE = re.compile(r<span class="PY_STRING">'\w+'</span>)
_equalsRE = re.compile(r<span class="PY_STRING">'\='</span>)
_stringRE = re.compile(r<span class="PY_STRING">'''"[^"]+"|'[^']+'|\S+'''</span>)
_whiteRE = re.compile(r<span class="PY_STRING">'\s+'</span>)

_REs = [_nameRE, _equalsRE, _stringRE, _whiteRE]


<span class="PY_KEYWORD">def</span> DictForArgs(s):
    <span class="PY_STRING">"""Build dictionary from arguments.

    Takes an input such as:
        x=3
        name="foo"
        first='john' last='doe'
        required border=3

    And returns a dictionary representing the same. For keys that aren't
    given an explicit value (such as 'required' above), the value is '1'.

    All values are interpreted as strings. If you want ints and floats,
    you'll have to convert them yourself.

    This syntax is equivalent to what you find in HTML and close to other
    ML languages such as XML.

    Returns {} for an empty string.

    The informal grammar is:
        (NAME [=NAME|STRING])*

    Will raise DictForArgsError if the string is invalid.

    See also: PyDictForArgs() and ExpandDictWithExtras() in this module.

    """</span>

    s = s.strip()

    <span class="PY_COMMENT"># Tokenize</span>

    verbose = False
    matches = []
    start = 0
    sLen = len(s)

    <span class="PY_KEYWORD">if</span> verbose:
        <span class="PY_KEYWORD">print</span> <span class="PY_STRING">'&gt;&gt; DictForArgs(%s)'</span> % repr(s)
        <span class="PY_KEYWORD">print</span> <span class="PY_STRING">'&gt;&gt; sLen:'</span>, sLen
    <span class="PY_KEYWORD">while</span> start &lt; sLen:
        <span class="PY_KEYWORD">for</span> regEx <span class="PY_KEYWORD">in</span> _REs:
            <span class="PY_KEYWORD">if</span> verbose:
                <span class="PY_KEYWORD">print</span> <span class="PY_STRING">'&gt;&gt; try:'</span>, regEx
            match = regEx.match(s, start)
            <span class="PY_KEYWORD">if</span> verbose:
                <span class="PY_KEYWORD">print</span> <span class="PY_STRING">'&gt;&gt; match:'</span>, match
            <span class="PY_KEYWORD">if</span> match <span class="PY_KEYWORD">is</span> <span class="PY_KEYWORD">not</span> None:
                <span class="PY_KEYWORD">if</span> match.re <span class="PY_KEYWORD">is</span> <span class="PY_KEYWORD">not</span> _whiteRE:
                    matches.append(match)
                start = match.end()
                <span class="PY_KEYWORD">if</span> verbose:
                    <span class="PY_KEYWORD">print</span> <span class="PY_STRING">'&gt;&gt; new start:'</span>, start
                <span class="PY_KEYWORD">break</span>
        <span class="PY_KEYWORD">else</span>:
            _SyntaxError(s)

    <span class="PY_KEYWORD">if</span> verbose:
        names = []
        <span class="PY_KEYWORD">for</span> match <span class="PY_KEYWORD">in</span> matches:
            <span class="PY_KEYWORD">if</span> match.re <span class="PY_KEYWORD">is</span> _nameRE:
                name = <span class="PY_STRING">'name'</span>
            <span class="PY_KEYWORD">elif</span> match.re <span class="PY_KEYWORD">is</span> _equalsRE:
                name = <span class="PY_STRING">'equals'</span>
            <span class="PY_KEYWORD">elif</span> match.re <span class="PY_KEYWORD">is</span> _stringRE:
                name = <span class="PY_STRING">'string'</span>
            <span class="PY_KEYWORD">elif</span> match.re <span class="PY_KEYWORD">is</span> _whiteRE:
                name = <span class="PY_STRING">'white'</span>
            names.append(name)
            <span class="PY_COMMENT">#print </span><span class="PY_STRING">'&gt;&gt; match ='</span>, name, match
        <span class="PY_KEYWORD">print</span> <span class="PY_STRING">'&gt;&gt; names ='</span>, names


    <span class="PY_COMMENT"># Process tokens</span>

    <span class="PY_COMMENT"># At this point we have a list of all the tokens (as re.Match objects)</span>
    <span class="PY_COMMENT"># We need to process these into a dictionary.</span>

    d = {}
    matchesLen = len(matches)
    i = 0
    <span class="PY_KEYWORD">while</span> i &lt; matchesLen:
        match = matches[i]
        <span class="PY_KEYWORD">if</span> i + 1 &lt; matchesLen:
            peekMatch = matches[i+1]
        <span class="PY_KEYWORD">else</span>:
            peekMatch = None
        <span class="PY_KEYWORD">if</span> match.re <span class="PY_KEYWORD">is</span> _nameRE:
            <span class="PY_KEYWORD">if</span> peekMatch <span class="PY_KEYWORD">is</span> <span class="PY_KEYWORD">not</span> None:
                <span class="PY_KEYWORD">if</span> peekMatch.re <span class="PY_KEYWORD">is</span> _nameRE:
                    <span class="PY_COMMENT"># We have a name without an explicit value</span>
                    d[match.group()] = <span class="PY_STRING">'1'</span>
                    i += 1
                    <span class="PY_KEYWORD">continue</span>
                <span class="PY_KEYWORD">if</span> peekMatch.re <span class="PY_KEYWORD">is</span> _equalsRE:
                    <span class="PY_KEYWORD">if</span> i + 2 &lt; matchesLen:
                        target = matches[i+2]
                        <span class="PY_KEYWORD">if</span> target.re <span class="PY_KEYWORD">is</span> _nameRE <span class="PY_KEYWORD">or</span> target.re <span class="PY_KEYWORD">is</span> _stringRE:
                            value = target.group()
                            <span class="PY_KEYWORD">if</span> value[0] == <span class="PY_STRING">"'"</span> <span class="PY_KEYWORD">or</span> value[0] == <span class="PY_STRING">'"'</span>:
                                value = value[1:-1]
                                <span class="PY_COMMENT"># value = "'''%s'''" % value[1:-1]</span>
                                <span class="PY_COMMENT"># value = eval(value)</span>
                            d[match.group()] = value
                            i += 3
                            <span class="PY_KEYWORD">continue</span>
            <span class="PY_KEYWORD">else</span>:
                d[match.group()] = <span class="PY_STRING">'1'</span>
                i += 1
                <span class="PY_KEYWORD">continue</span>
        _SyntaxError(s)

    <span class="PY_KEYWORD">if</span> verbose:
        <span class="PY_KEYWORD">print</span>

    <span class="PY_KEYWORD">return</span> d


<span class="PY_KEYWORD">def</span> PyDictForArgs(s):
    <span class="PY_STRING">"""Build dictionary from arguments.

    Takes an input such as:
        x=3
        name="foo"
        first='john'; last='doe'
        list=[1, 2, 3]; name='foo'

    And returns a dictionary representing the same.

    All values are interpreted as Python expressions. Any error in these
    expressions will raise the appropriate Python exception. This syntax
    allows much more power than DictForArgs() since you can include
    lists, dictionaries, actual ints and floats, etc.

    This could also open the door to hacking your software if the input
    comes from a tainted source such as an HTML form or an unprotected
    configuration file.

    Returns {} for an empty string.

    See also: DictForArgs() and ExpandDictWithExtras() in this module.

    """</span>
    <span class="PY_KEYWORD">if</span> s:
        s = s.strip()
    <span class="PY_KEYWORD">if</span> <span class="PY_KEYWORD">not</span> s:
        <span class="PY_KEYWORD">return</span> {}

    <span class="PY_COMMENT"># special case: just a name</span>
    <span class="PY_COMMENT"># meaning: name=1</span>
    <span class="PY_COMMENT"># example: isAbstract</span>
    <span class="PY_KEYWORD">if</span> <span class="PY_STRING">' '</span> <span class="PY_KEYWORD">not</span> <span class="PY_KEYWORD">in</span> s <span class="PY_KEYWORD">and</span> <span class="PY_STRING">'='</span> <span class="PY_KEYWORD">not</span> <span class="PY_KEYWORD">in</span> s <span class="PY_KEYWORD">and</span> s[0].isalpha():
        s += <span class="PY_STRING">'=1'</span>

    results = {}
    <span class="PY_KEYWORD">exec</span> s <span class="PY_KEYWORD">in</span> results

    <span class="PY_KEYWORD">del</span> results[<span class="PY_STRING">'__builtins__'</span>]
    <span class="PY_KEYWORD">return</span> results


<span class="PY_KEYWORD">def</span> ExpandDictWithExtras(d, key=<span class="PY_STRING">'Extras'</span>, delKey=True, dictForArgs=DictForArgs):
    <span class="PY_STRING">"""Return a dictionary with the 'Extras' column expanded by DictForArgs().

    For example, given:
        {'Name': 'foo', 'Extras': 'x=1 y=2'}
    The return value is:
        {'Name': 'foo', 'x': '1', 'y': '2'}
    The key argument controls what key in the dictionary is used to hold
    the extra arguments. The delKey argument controls whether that key and
    its corresponding value are retained.
    The same dictionary may be returned if there is no extras key.
    The most typical use of this function is to pass a row from a DataTable
    that was initialized from a CSV file (e.g., a spreadsheet or tabular file).
    FormKit and MiddleKit both use CSV files and allow for an Extras column
    to specify attributes that occur infrequently.

    """</span>
    <span class="PY_KEYWORD">if</span> key <span class="PY_KEYWORD">in</span> d:
        newDict = dict(d)
        <span class="PY_KEYWORD">if</span> delKey:
            <span class="PY_KEYWORD">del</span> newDict[key]
        newDict.update(dictForArgs(d[key]))
        <span class="PY_KEYWORD">return</span> newDict
    <span class="PY_KEYWORD">else</span>:
        <span class="PY_KEYWORD">return</span> d
</pre>
<!--footer-->

</body>
</html>
