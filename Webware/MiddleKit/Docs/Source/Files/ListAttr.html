<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>MiddleKit/Core/ListAttr.py</title>
<!--css-->

<style type="text/css">
<!--
body{ background: #EEF;
font-family: Verdana, Arial, Helvetica, sans-serif;
font-size: 10pt;
padding: 3pt; }
.PY_KEYWORD{ color: #00C; font-weight: bold; }
.PY_COMMENT{ color: #008; }
.PY_PARAMETER{ color: #C00; }
.PY_IDENTIFIER{ color: #C00; font-weight: bold; }
.PY_STRING{ color: #080; }
-->
</style>
</head>
<body>
<!--header-->

<!--script-->
<pre><span class="PY_KEYWORD">from</span> Attr <span class="PY_KEYWORD">import</span> Attr


<span class="PY_KEYWORD">class</span> ListAttr(Attr):
    <span class="PY_STRING">"""This is an attribute that refers to a set of other user-defined objects.

    It cannot include basic data types or instances of classes that are not part
    of the object model.

    """</span>

    <span class="PY_KEYWORD">def</span> __init__(self, attr):
        Attr.__init__(self, attr)
        self._className = attr[<span class="PY_STRING">'Type'</span>].rsplit(None, 1)[-1]
        self._backRefAttr = None <span class="PY_COMMENT"># init'ed in awakeFromRead()</span>
        <span class="PY_KEYWORD">if</span> self.get(<span class="PY_STRING">'Min'</span>) <span class="PY_KEYWORD">is</span> <span class="PY_KEYWORD">not</span> None:
            self[<span class="PY_STRING">'Min'</span>] = int(self[<span class="PY_STRING">'Min'</span>])
        <span class="PY_KEYWORD">if</span> self.get(<span class="PY_STRING">'Max'</span>) <span class="PY_KEYWORD">is</span> <span class="PY_KEYWORD">not</span> None:
            self[<span class="PY_STRING">'Max'</span>] = int(self[<span class="PY_STRING">'Max'</span>])

    <span class="PY_KEYWORD">def</span> className(self):
        <span class="PY_STRING">"""Return the name of the base class that this obj ref attribute points to."""</span>
        <span class="PY_KEYWORD">return</span> self._className

    <span class="PY_KEYWORD">def</span> backRefAttrName(self):
        <span class="PY_STRING">"""Return the name of the back-reference attribute in the referenced class.

        It is necessary to be able to override the default back ref     to create
        data structures like trees, in which a Middle object might reference
        a parent and multiple children, all of the same class as itself.

        """</span>
        <span class="PY_KEYWORD">assert</span> self._backRefAttr <span class="PY_KEYWORD">is</span> <span class="PY_KEYWORD">not</span> None
        <span class="PY_KEYWORD">return</span> self._backRefAttr

    <span class="PY_KEYWORD">def</span> awakeFromRead(self):
        <span class="PY_STRING">"""Check that the target class and backRefAttr actually exist."""</span>
        <span class="PY_COMMENT"># Check that for "list of Foo", Foo actually exists. And,</span>
        <span class="PY_COMMENT"># Compute self._targetKlass.</span>
        <span class="PY_KEYWORD">from</span> Model <span class="PY_KEYWORD">import</span> ModelError
        self._targetKlass = self.model().klass(self.className(), None)
        <span class="PY_KEYWORD">if</span> <span class="PY_KEYWORD">not</span> self._targetKlass:
            <span class="PY_KEYWORD">raise</span> ModelError(<span class="PY_STRING">'class %s: attr %s:'</span>
                <span class="PY_STRING">' cannot locate target class %s for this list.'</span>
                % (self.klass().name(), self.name(), self.className()))

        <span class="PY_COMMENT"># Compute self._backRefAttr.</span>
        <span class="PY_KEYWORD">if</span> <span class="PY_STRING">'BackRefAttr'</span> <span class="PY_KEYWORD">in</span> self:
            backRefName = self[<span class="PY_STRING">'BackRefAttr'</span>]
        <span class="PY_KEYWORD">else</span>:
            backRefName = self.klass().name()
            attr = self._targetKlass.lookupAttr(backRefName, None)
            <span class="PY_KEYWORD">if</span> attr <span class="PY_KEYWORD">is</span> None:
                className = self.klass().name()
                backRefName = className[0].lower() + className[1:]
        self._backRefAttr = backRefName

        <span class="PY_COMMENT"># Check that the backRefAttr, whether explicit or implicit, exists in the target class.</span>
        backRefAttr = self._targetKlass.lookupAttr(self.backRefAttrName(), None)
        <span class="PY_KEYWORD">if</span> backRefAttr <span class="PY_KEYWORD">is</span> None:
            <span class="PY_KEYWORD">raise</span> ModelError(<span class="PY_STRING">'class %s: attr %s: cannot locate backref attr'</span>
                <span class="PY_STRING">' %s.%s for this list.'</span> % (self.klass().name(), self.name(),
                self.className(), self.backRefAttrName()))
        backRefAttr[<span class="PY_STRING">'isBackRefAttr'</span>] = True
</pre>
<!--footer-->

</body>
</html>
