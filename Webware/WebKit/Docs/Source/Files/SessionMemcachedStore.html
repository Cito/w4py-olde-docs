<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>WebKit/SessionMemcachedStore.py</title>
<!--css-->

<style type="text/css">
<!--
body{ background: #EEF;
font-family: Verdana, Arial, Helvetica, sans-serif;
font-size: 10pt;
padding: 3pt; }
.PY_KEYWORD{ color: #00C; font-weight: bold; }
.PY_COMMENT{ color: #008; }
.PY_PARAMETER{ color: #C00; }
.PY_IDENTIFIER{ color: #C00; font-weight: bold; }
.PY_STRING{ color: #080; }
-->
</style>
</head>
<body>
<!--header-->

<!--script-->
<pre><span class="PY_STRING">"""Session store using the Memcached memory object caching system."""</span>

<span class="PY_KEYWORD">from</span> warnings <span class="PY_KEYWORD">import</span> warn
<span class="PY_KEYWORD">try</span>:
    <span class="PY_KEYWORD">from</span> cPickle <span class="PY_KEYWORD">import</span> HIGHEST_PROTOCOL <span class="PY_KEYWORD">as</span> maxPickleProtocol
<span class="PY_KEYWORD">except</span> ImportError:
    <span class="PY_KEYWORD">from</span> pickle <span class="PY_KEYWORD">import</span> HIGHEST_PROTOCOL <span class="PY_KEYWORD">as</span> maxPickleProtocol

<span class="PY_KEYWORD">try</span>:
    <span class="PY_KEYWORD">import</span> memcache
<span class="PY_KEYWORD">except</span> Exception:
    <span class="PY_KEYWORD">raise</span> ImportError(<span class="PY_STRING">"For using Memcached sessions,"</span>
        <span class="PY_STRING">" python-memcached must be installed."</span>)

<span class="PY_KEYWORD">from</span> MiscUtils <span class="PY_KEYWORD">import</span> NoDefault

<span class="PY_KEYWORD">from</span> SessionStore <span class="PY_KEYWORD">import</span> SessionStore

debug = False


<span class="PY_KEYWORD">class</span> SessionMemcachedStore(SessionStore):
    <span class="PY_STRING">"""A session store using Memached.

    Stores the sessions in a single Memcached store using 'last write wins'
    semantics. This increases fault tolerance and allows server clustering.
    In clustering configurations with concurrent writes for the same
    session(s) the last writer will always overwrite the session.

    The keys are prefixed with a configurable namespace, allowing you to
    store other data in the same Memcached system.

    Cleaning/timing out of sessions is performed by Memcached itself
    since no one app server can know about the existence of all sessions or
    the last access for a given session. Besides it is built in Memcached
    functionality. Consequently, correct sizing of Memcached is necessary
    to hold all user's session data.

    Due to the way Memcached works, methods requiring access to the keys
    or for clearing the store do not work. You can configure whether you
    want to ignore such calls or raise an error in this case. By default,
    you will get a warning. It would be possible to emulate these functions
    by storing additional data in the memcache, such as a namespace counter
    or the number or even the full list of keys. However, if you are using
    more than one app server instance, this would require fetching that data
    every time, since we cannot know whether another instance changed it.
    So we refrained from doing such sophisticated trickery and instead kept
    the implementation intentionally very simple and fast.

    You need to install python-memcached to be able to use this module:
    http://www.tummy.com/Community/software/python-memcached/
    You also need a Memcached server: http://memcached.org

    Contributed by Steve Schwarz, March 2010.
    Small improvements by Christoph Zwerschke, April 2010.

    """</span>

    <span class="PY_COMMENT">## Init ##
</span>

    <span class="PY_KEYWORD">def</span> __init__(self, app):
        SessionStore.__init__(self, app)

        <span class="PY_COMMENT"># the list of memcached servers
</span>
        self._servers = app.setting(<span class="PY_STRING">'MemcachedServers'</span>, [<span class="PY_STRING">'localhost:11211'</span>])

        <span class="PY_COMMENT"># timeout in seconds
</span>
        self._sessionTimeout = app.setting(
            <span class="PY_STRING">'SessionTimeout'</span>, 180) * 60

        <span class="PY_COMMENT"># the memcached "namespace" used by our store
</span>
        <span class="PY_COMMENT"># you can add an integer counter for expiration
</span>
        self._namespace = app.setting(
            <span class="PY_STRING">'MemcachedNamespace'</span>, <span class="PY_STRING">'WebwareSession'</span>) <span class="PY_KEYWORD">or</span> <span class="PY_STRING">''</span>

        <span class="PY_COMMENT"># when trying to iterate over the Memcached store,
</span>
        <span class="PY_COMMENT"># you can trigger an error or a warning
</span>
        self._onIteration = app.setting(<span class="PY_STRING">'MemcachedOnIteration'</span>, <span class="PY_STRING">'Warning'</span>)

        self._client = memcache.Client(self._servers,
            debug=debug, pickleProtocol=maxPickleProtocol)


    <span class="PY_COMMENT">## Access ##
</span>

    <span class="PY_KEYWORD">def</span> __len__(self):
        <span class="PY_STRING">"""Return the number of sessions in the store.

        Not supported by Memcached (see FAQ for explanation).

        """</span>
        <span class="PY_KEYWORD">if</span> debug:
            <span class="PY_KEYWORD">print</span> <span class="PY_STRING">"&gt;&gt; len()"</span>
        <span class="PY_KEYWORD">return</span> len(self.keys())

    <span class="PY_KEYWORD">def</span> __getitem__(self, key):
        <span class="PY_STRING">"""Get a session item, reading it from the store."""</span>
        <span class="PY_KEYWORD">if</span> debug:
            <span class="PY_KEYWORD">print</span> <span class="PY_STRING">"&gt;&gt; getitem(%s)"</span> % key
        <span class="PY_COMMENT"># returns None if key non-existent or no server to contact
</span>
        <span class="PY_KEYWORD">try</span>:
            value = self._client.get(self.mcKey(key))
        <span class="PY_KEYWORD">except</span> Exception:
            value = None
        <span class="PY_KEYWORD">if</span> value <span class="PY_KEYWORD">is</span> None:
            <span class="PY_COMMENT"># SessionStore expects KeyError when no result
</span>
            <span class="PY_KEYWORD">raise</span> KeyError(key)
        <span class="PY_KEYWORD">return</span> value

    <span class="PY_KEYWORD">def</span> __setitem__(self, key, value):
        <span class="PY_STRING">"""Set a session item, writing it to the store."""</span>
        <span class="PY_KEYWORD">if</span> debug:
            <span class="PY_KEYWORD">print</span> <span class="PY_STRING">"&gt;&gt; setitem(%s, %s)"</span> % (key, value)
        dirty = value.isDirty()
        <span class="PY_KEYWORD">if</span> self._alwaysSave <span class="PY_KEYWORD">or</span> dirty:
            <span class="PY_KEYWORD">if</span> dirty:
                value.setDirty(False)
            <span class="PY_KEYWORD">try</span>:
                <span class="PY_KEYWORD">if</span> <span class="PY_KEYWORD">not</span> self._client.set(self.mcKey(key), value,
                        time=self._sessionTimeout):
                    <span class="PY_KEYWORD">raise</span> ValueError(<span class="PY_STRING">"Setting value in the memcache failed."</span>)
            <span class="PY_KEYWORD">except</span> Exception, exc:
                <span class="PY_KEYWORD">if</span> dirty:
                    value.setDirty()
                <span class="PY_COMMENT"># Not able to store the session is a failure
</span>
                <span class="PY_KEYWORD">print</span> <span class="PY_STRING">"Error saving session '%s' to memcache: %s"</span> % (key, exc)
                self.application().handleException()

    <span class="PY_KEYWORD">def</span> __delitem__(self, key):
        <span class="PY_STRING">"""Delete a session item from the store.

        Note that in contracts with SessionFileStore,
        not finding a key to delete isn't a KeyError.

        """</span>
        <span class="PY_KEYWORD">if</span> debug:
            <span class="PY_KEYWORD">print</span> <span class="PY_STRING">"&gt;&gt; delitem(%s)"</span> % key
        session = self[key]
        <span class="PY_KEYWORD">if</span> <span class="PY_KEYWORD">not</span> session.isExpired():
            session.expiring()
        <span class="PY_KEYWORD">try</span>:
            <span class="PY_KEYWORD">if</span> <span class="PY_KEYWORD">not</span> self._client.delete(self.mcKey(key)):
                <span class="PY_KEYWORD">raise</span> ValueError(<span class="PY_STRING">"Deleting value from the memcache failed."</span>)
        <span class="PY_KEYWORD">except</span> Exception, exc:
            <span class="PY_COMMENT"># Not able to delete the session is a failure
</span>
            <span class="PY_KEYWORD">print</span> <span class="PY_STRING">"Error deleting session '%s' from memcache: %s"</span> % (key, exc)
            self.application().handleException()

    <span class="PY_KEYWORD">def</span> __contains__(self, key):
        <span class="PY_STRING">"""Check whether the session store has a given key."""</span>
        <span class="PY_KEYWORD">if</span> debug:
            <span class="PY_KEYWORD">print</span> <span class="PY_STRING">"&gt;&gt; contains(%s)"</span> % key
        <span class="PY_KEYWORD">try</span>:
            <span class="PY_KEYWORD">return</span> self._client.get(self.mcKey(key)) <span class="PY_KEYWORD">is</span> <span class="PY_KEYWORD">not</span> None
        <span class="PY_KEYWORD">except</span> Exception:
            <span class="PY_KEYWORD">return</span> False

    <span class="PY_KEYWORD">def</span> __iter__(self):
        <span class="PY_STRING">"""Return an iterator over the stored session keys.

        Not supported by Memcached (see FAQ for explanation).

        """</span>
        <span class="PY_KEYWORD">if</span> debug:
            <span class="PY_KEYWORD">print</span> <span class="PY_STRING">"&gt;&gt; iter()"</span>
        onIteration = self._onIteration
        <span class="PY_KEYWORD">if</span> onIteration:
            err = <span class="PY_STRING">'Memcached does not support iteration.'</span>
            <span class="PY_KEYWORD">if</span> onIteration == <span class="PY_STRING">'Error'</span>:
                <span class="PY_KEYWORD">raise</span> NotImplementedError(err)
            <span class="PY_KEYWORD">else</span>:
                warn(err)
        <span class="PY_KEYWORD">return</span> iter([])

    <span class="PY_KEYWORD">def</span> keys(self):
        <span class="PY_STRING">"""Return a list with the keys of all the stored sessions.

        Not supported by Memcached (see FAQ for explanation).

        """</span>
        <span class="PY_KEYWORD">if</span> debug:
            <span class="PY_KEYWORD">print</span> <span class="PY_STRING">"&gt;&gt; keys()"</span>
        <span class="PY_KEYWORD">return</span> [key <span class="PY_KEYWORD">for</span> key <span class="PY_KEYWORD">in</span> self]

    <span class="PY_KEYWORD">def</span> clear(self):
        <span class="PY_STRING">"""Clear the session store, removing all of its items.

        Not supported by Memcached. We could emulate this by incrementing
        an additional namespace counter, but then we would need to fetch
        the current counter from the memcache before every access in order
        to keep different app server instances in sync.

        """</span>
        <span class="PY_KEYWORD">if</span> debug:
            <span class="PY_KEYWORD">print</span> <span class="PY_STRING">"&gt;&gt; clear()"</span>
        <span class="PY_KEYWORD">if</span> self._onIteration:
            err = <span class="PY_STRING">'Memcached does not support clearing the store.'</span>
            <span class="PY_KEYWORD">if</span> self._onIteration == <span class="PY_STRING">'Error'</span>:
                <span class="PY_KEYWORD">raise</span> NotImplementedError(err)
            <span class="PY_KEYWORD">else</span>:
                warn(err)

    <span class="PY_KEYWORD">def</span> setdefault(self, key, default=None):
        <span class="PY_STRING">"""Return value if key available, else default (also setting it)."""</span>
        <span class="PY_KEYWORD">if</span> debug:
            <span class="PY_KEYWORD">print</span> <span class="PY_STRING">"&gt;&gt; setdefault(%s, %s)"</span> % (key, default)
        <span class="PY_KEYWORD">try</span>:
            <span class="PY_KEYWORD">return</span> self[key]
        <span class="PY_KEYWORD">except</span> KeyError:
            self[key] = default
            <span class="PY_KEYWORD">return</span> default

    <span class="PY_KEYWORD">def</span> pop(self, key, default=NoDefault):
        <span class="PY_STRING">"""Return value if key available, else default (also remove key)."""</span>
        <span class="PY_KEYWORD">if</span> debug:
            <span class="PY_KEYWORD">print</span> <span class="PY_STRING">"&gt;&gt; pop(%s, %s)"</span> % (key, default)
        <span class="PY_KEYWORD">if</span> default <span class="PY_KEYWORD">is</span> NoDefault:
            value = self[key]
            <span class="PY_KEYWORD">del</span> self[key]
            <span class="PY_KEYWORD">return</span> value
        <span class="PY_KEYWORD">else</span>:
            <span class="PY_KEYWORD">try</span>:
                value = self[key]
            <span class="PY_KEYWORD">except</span> KeyError:
                <span class="PY_KEYWORD">return</span> default
            <span class="PY_KEYWORD">else</span>:
                <span class="PY_KEYWORD">del</span> self[key]
                <span class="PY_KEYWORD">return</span> value


    <span class="PY_COMMENT">## Application support ##
</span>

    <span class="PY_KEYWORD">def</span> storeSession(self, session):
        <span class="PY_STRING">"""Save potentially changed session in the store."""</span>
        <span class="PY_KEYWORD">if</span> debug:
            <span class="PY_KEYWORD">print</span> <span class="PY_STRING">"&gt;&gt; storeSession(%s)"</span> % session
        self[session.identifier()] = session

    <span class="PY_KEYWORD">def</span> storeAllSessions(self):
        <span class="PY_STRING">"""Permanently save all sessions in the store.

        Should be used (only) when the application server is shut down.
        This closes the connection to the Memcached servers.

        """</span>
        <span class="PY_KEYWORD">if</span> debug:
            <span class="PY_KEYWORD">print</span> <span class="PY_STRING">"&gt;&gt; storeAllSessions()"</span>
        self._client.disconnect_all()

    <span class="PY_KEYWORD">def</span> cleanStaleSessions(self, task=None):
        <span class="PY_STRING">"""Clean stale sessions.

        Memcached does this on its own, so we do nothing here.

        """</span>
        <span class="PY_KEYWORD">if</span> debug:
            <span class="PY_KEYWORD">print</span> <span class="PY_STRING">"&gt;&gt; cleanStaleSessions()"</span>


    <span class="PY_COMMENT">## Auxiliary methods ##
</span>

    <span class="PY_KEYWORD">def</span> mcKey(self, key):
        <span class="PY_STRING">"""Create the real key with namespace to be used with Memcached."""</span>
        <span class="PY_KEYWORD">return</span> self._namespace + key
</pre>
<!--footer-->

</body>
</html>
