<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>WebKit/HTTPRequest.py</title>
<!--css-->

<style type="text/css">
<!--
body{ background: #EEF;
font-family: Verdana, Arial, Helvetica, sans-serif;
font-size: 10pt;
padding: 3pt; }
.PY_KEYWORD{ color: #00C; font-weight: bold; }
.PY_COMMENT{ color: #008; }
.PY_PARAMETER{ color: #C00; }
.PY_IDENTIFIER{ color: #C00; font-weight: bold; }
.PY_STRING{ color: #080; }
-->
</style>
</head>
<body>
<!--header-->

<!--script-->
<pre><span class="PY_STRING">"""HTTP requests"""</span>

<span class="PY_KEYWORD">import</span> cgi
<span class="PY_KEYWORD">import</span> os
<span class="PY_KEYWORD">import</span> sys
<span class="PY_KEYWORD">import</span> traceback
<span class="PY_KEYWORD">from</span> operator <span class="PY_KEYWORD">import</span> attrgetter, itemgetter
<span class="PY_KEYWORD">from</span> time <span class="PY_KEYWORD">import</span> time

<span class="PY_KEYWORD">from</span> MiscUtils <span class="PY_KEYWORD">import</span> NoDefault
<span class="PY_KEYWORD">from</span> WebUtils <span class="PY_KEYWORD">import</span> FieldStorage
<span class="PY_KEYWORD">from</span> WebKit.Cookie <span class="PY_KEYWORD">import</span> CookieEngine
Cookie = CookieEngine.SimpleCookie
<span class="PY_KEYWORD">from</span> Request <span class="PY_KEYWORD">import</span> Request
<span class="PY_KEYWORD">import</span> HTTPResponse

debug = False


<span class="PY_KEYWORD">class</span> HTTPRequest(Request):
    <span class="PY_STRING">"""A type of Message for HTTP requests."""</span>


    <span class="PY_COMMENT">## Initialization ##</span>

    <span class="PY_KEYWORD">def</span> __init__(self, requestDict=None):
        Request.__init__(self)
        self._stack = []
        <span class="PY_KEYWORD">if</span> requestDict:
            <span class="PY_COMMENT"># Dictionaries come in from web server adapters like the CGIAdapter</span>
            <span class="PY_KEYWORD">assert</span> requestDict[<span class="PY_STRING">'format'</span>] == <span class="PY_STRING">'CGI'</span>
            self._time = requestDict[<span class="PY_STRING">'time'</span>]
            self._environ = requestDict[<span class="PY_STRING">'environ'</span>]
            self._input = requestDict[<span class="PY_STRING">'input'</span>]
            self._requestID = requestDict[<span class="PY_STRING">'requestID'</span>]
            self._fields = FieldStorage.FieldStorage(
                self._input, environ=self._environ,
                keep_blank_values=True, strict_parsing=False)
            self._cookies = Cookie()
            <span class="PY_KEYWORD">if</span> <span class="PY_STRING">'HTTP_COOKIE'</span> <span class="PY_KEYWORD">in</span> self._environ:
                <span class="PY_COMMENT"># Protect the loading of cookies with an exception handler,</span>
                <span class="PY_COMMENT"># because MSIE cookies sometimes can break the cookie module.</span>
                <span class="PY_KEYWORD">try</span>:
                    self._cookies.load(self._environ[<span class="PY_STRING">'HTTP_COOKIE'</span>])
                <span class="PY_KEYWORD">except</span> Exception:
                    traceback.print_exc(file=sys.stderr)
        <span class="PY_KEYWORD">else</span>:
            <span class="PY_COMMENT"># If there's no dictionary, we pretend we're a CGI script</span>
            <span class="PY_COMMENT"># and see what happens...</span>
            self._time = time()
            self._environ = os.environ.copy()
            self._input = None
            self._fields = cgi.FieldStorage(keep_blank_values=True)
            self._cookies = Cookie()

        env = self._environ

        <span class="PY_COMMENT"># Debugging</span>
        <span class="PY_KEYWORD">if</span> debug:
            f = open(<span class="PY_STRING">'env.text'</span>, <span class="PY_STRING">'a'</span>)
            save = sys.stdout
            sys.stdout = f
            <span class="PY_KEYWORD">print</span> <span class="PY_STRING">'&gt;&gt; env for request:'</span>
            <span class="PY_KEYWORD">for</span> key <span class="PY_KEYWORD">in</span> sorted(env):
                <span class="PY_KEYWORD">print</span> <span class="PY_STRING">'%s: %s'</span> % (repr(key), repr(env[key]))
            <span class="PY_KEYWORD">print</span>
            sys.stdout = save
            f.close()

        <span class="PY_COMMENT"># Get adapter, servlet path and query string</span>
        self._absolutepath = <span class="PY_STRING">'WK_ABSOLUTE'</span> <span class="PY_KEYWORD">in</span> env <span class="PY_COMMENT"># set by adapter</span>
        <span class="PY_KEYWORD">if</span> self._absolutepath:
            <span class="PY_COMMENT"># this is set when the servlet is a webserver file that shall</span>
            <span class="PY_COMMENT"># be handled without context (e.g. when the psp-handler is used)</span>
            self._servletPath = <span class="PY_STRING">''</span> <span class="PY_COMMENT"># make it look like the normal handler</span>
            self._extraURLPath = env.get(<span class="PY_STRING">'PATH_INFO'</span>, <span class="PY_STRING">''</span>)
            self._pathInfo = env.get(<span class="PY_STRING">'SCRIPT_NAME'</span>, <span class="PY_STRING">''</span>) + self._extraURLPath
            self._fsPath = self.fsPath()
        <span class="PY_KEYWORD">else</span>:
            self._servletPath = env.get(<span class="PY_STRING">'SCRIPT_NAME'</span>, <span class="PY_STRING">''</span>)
            self._pathInfo = env.get(<span class="PY_STRING">'PATH_INFO'</span>, <span class="PY_STRING">''</span>)
            self._extraURLPath = <span class="PY_STRING">''</span> <span class="PY_COMMENT"># will be determined later</span>
        self._queryString = env.get(<span class="PY_STRING">'QUERY_STRING'</span>, <span class="PY_STRING">''</span>)
        <span class="PY_KEYWORD">if</span> <span class="PY_STRING">'REQUEST_URI'</span> <span class="PY_KEYWORD">in</span> env:
            self._uri = env[<span class="PY_STRING">'REQUEST_URI'</span>]
            <span class="PY_COMMENT"># correct servletPath if there was a redirection</span>
            <span class="PY_KEYWORD">if</span> <span class="PY_KEYWORD">not</span> (self._uri + <span class="PY_STRING">'/'</span>).startswith(self._servletPath + <span class="PY_STRING">'/'</span>):
                i = self._uri.find(self._pathInfo)
                self._servletPath = i &gt; 0 <span class="PY_KEYWORD">and</span> self._uri[:i] <span class="PY_KEYWORD">or</span> <span class="PY_STRING">''</span>
        <span class="PY_KEYWORD">else</span>:
            <span class="PY_COMMENT"># REQUEST_URI isn't actually part of the CGI standard and some</span>
            <span class="PY_COMMENT"># web servers like IIS don't set it (as of 8/22/2000).</span>
            <span class="PY_KEYWORD">if</span> <span class="PY_STRING">'SCRIPT_URL'</span> <span class="PY_KEYWORD">in</span> env:
                self._uri = self._environ[<span class="PY_STRING">'SCRIPT_URL'</span>]
                <span class="PY_COMMENT"># correct servletPath if there was a redirection</span>
                <span class="PY_KEYWORD">if</span> <span class="PY_KEYWORD">not</span> (self._uri + <span class="PY_STRING">'/'</span>).startswith(self._servletPath + <span class="PY_STRING">'/'</span>):
                    i = self._uri.find(self._pathInfo)
                    self._servletPath = i &gt; 0 <span class="PY_KEYWORD">and</span> self._uri[:i] <span class="PY_KEYWORD">or</span> <span class="PY_STRING">''</span>
            <span class="PY_KEYWORD">else</span>:
                self._uri = self._servletPath + self._pathInfo
            <span class="PY_KEYWORD">if</span> self._queryString:
                self._uri += <span class="PY_STRING">'?'</span> + self._queryString

        <span class="PY_COMMENT"># We use the cgi module to get the fields,</span>
        <span class="PY_COMMENT"># but then change them into an ordinary dictionary of values:</span>
        fieldStorage, fields = self._fields, {}
        <span class="PY_KEYWORD">try</span>:
            <span class="PY_COMMENT"># Avoid accessing fieldStorage as dict; that would be very slow</span>
            <span class="PY_COMMENT"># as it always iterates over all items to find a certain key.</span>
            <span class="PY_COMMENT"># Instead, iterate directly over the items of the internal list.</span>
            fieldItems = fieldStorage.list
        <span class="PY_KEYWORD">except</span> AttributeError:
            <span class="PY_COMMENT"># This can happen if we do not have a a regular POST</span>
            <span class="PY_COMMENT"># from an HTML form, but, for example, an XML-RPC request.</span>
            fieldItems = None
            <span class="PY_KEYWORD">if</span> debug:
                <span class="PY_KEYWORD">print</span> <span class="PY_STRING">"Cannot get fieldstorage list."</span>
        <span class="PY_KEYWORD">if</span> fieldItems:
            <span class="PY_KEYWORD">for</span> value <span class="PY_KEYWORD">in</span> fieldItems:
                fields.setdefault(value.name, []).append(value)
            getValue = attrgetter(<span class="PY_STRING">'value'</span>)
            <span class="PY_KEYWORD">for</span> key, value <span class="PY_KEYWORD">in</span> fields.iteritems():
                <span class="PY_KEYWORD">if</span> len(value) &gt; 1:
                    value = map(getValue, value)
                <span class="PY_KEYWORD">else</span>:
                    value = value[0]
                    <span class="PY_KEYWORD">if</span> value.filename:
                        <span class="PY_KEYWORD">if</span> debug:
                            <span class="PY_KEYWORD">print</span> <span class="PY_STRING">"Uploaded file found:"</span>, value.filename
                    <span class="PY_KEYWORD">else</span>:
                        value = value.value
                fields[key] = value
        self._fieldStorage, self._fields = fieldStorage, fields

        <span class="PY_COMMENT"># We use Tim O'Malley's Cookie class to get the cookies,</span>
        <span class="PY_COMMENT"># but then change them into an ordinary dictionary of values</span>
        self._cookies = dict(
            (key, self._cookies[key].value) <span class="PY_KEYWORD">for</span> key <span class="PY_KEYWORD">in</span> self._cookies)

        self._contextName = None
        self._serverSidePath = self._serverSideContextPath = None
        self._serverRootPath = <span class="PY_STRING">''</span>
        self._sessionExpired = False

        self._pathInfo = self.pathInfo()

        <span class="PY_KEYWORD">if</span> debug:
            <span class="PY_KEYWORD">print</span> <span class="PY_STRING">"Done setting up request, found keys %r"</span> % fields.keys()


    <span class="PY_COMMENT">## Protocol ##</span>

    <span class="PY_KEYWORD">def</span> protocol(self):
        <span class="PY_STRING">"""Return the name and version of the protocol."""</span>
        <span class="PY_KEYWORD">return</span> self._environ.get(<span class="PY_STRING">'SERVER_PROTOCOL'</span>, <span class="PY_STRING">'HTTP/1.0'</span>)


    <span class="PY_COMMENT">## Security ##</span>

    <span class="PY_KEYWORD">def</span> isSecure(self):
        <span class="PY_STRING">"""Check whether this is a HTTPS connection."""</span>
        <span class="PY_KEYWORD">return</span> self._environ.get(<span class="PY_STRING">'HTTPS'</span>, <span class="PY_STRING">''</span>).lower() == <span class="PY_STRING">'on'</span>


    <span class="PY_COMMENT">## Transactions ##</span>

    <span class="PY_KEYWORD">def</span> responseClass(self):
        <span class="PY_KEYWORD">return</span> HTTPResponse.HTTPResponse


    <span class="PY_COMMENT">## Values ##</span>

    <span class="PY_KEYWORD">def</span> value(self, name, default=NoDefault):
        <span class="PY_STRING">"""Return the value with the given name.

        Values are fields or cookies.
        Use this method when you're field/cookie agnostic.

        """</span>
        <span class="PY_KEYWORD">if</span> name <span class="PY_KEYWORD">in</span> self._fields:
            <span class="PY_KEYWORD">return</span> self._fields[name]
        <span class="PY_KEYWORD">else</span>:
            <span class="PY_KEYWORD">return</span> self.cookie(name, default)

    <span class="PY_KEYWORD">def</span> hasValue(self, name):
        <span class="PY_STRING">"""Check whether there is a value with the given name."""</span>
        <span class="PY_KEYWORD">return</span> name <span class="PY_KEYWORD">in</span> self._fields <span class="PY_KEYWORD">or</span> name <span class="PY_KEYWORD">in</span> self._cookies

    <span class="PY_KEYWORD">def</span> extraURLPath(self):
        <span class="PY_STRING">"""Return additional path components in the URL.

        Only works if the Application.config setting "ExtraPathInfo"
        is set to true; otherwise you will get a page not found error.

        """</span>
        <span class="PY_KEYWORD">return</span> self._extraURLPath


    <span class="PY_COMMENT">## Fields ##</span>

    <span class="PY_KEYWORD">def</span> fieldStorage(self):
        <span class="PY_KEYWORD">return</span> self._fieldStorage

    <span class="PY_KEYWORD">def</span> field(self, name, default=NoDefault):
        <span class="PY_KEYWORD">if</span> default <span class="PY_KEYWORD">is</span> NoDefault:
            <span class="PY_KEYWORD">return</span> self._fields[name]
        <span class="PY_KEYWORD">else</span>:
            <span class="PY_KEYWORD">return</span> self._fields.get(name, default)

    <span class="PY_KEYWORD">def</span> hasField(self, name):
        <span class="PY_KEYWORD">return</span> name <span class="PY_KEYWORD">in</span> self._fields

    <span class="PY_KEYWORD">def</span> fields(self):
        <span class="PY_KEYWORD">return</span> self._fields

    <span class="PY_KEYWORD">def</span> setField(self, name, value):
        self._fields[name] = value

    <span class="PY_KEYWORD">def</span> delField(self, name):
        <span class="PY_KEYWORD">del</span> self._fields[name]


    <span class="PY_COMMENT">## Cookies ##</span>

    <span class="PY_KEYWORD">def</span> cookie(self, name, default=NoDefault):
        <span class="PY_STRING">"""Return the value of the specified cookie."""</span>
        <span class="PY_KEYWORD">if</span> default <span class="PY_KEYWORD">is</span> NoDefault:
            <span class="PY_KEYWORD">return</span> self._cookies[name]
        <span class="PY_KEYWORD">else</span>:
            <span class="PY_KEYWORD">return</span> self._cookies.get(name, default)

    <span class="PY_KEYWORD">def</span> hasCookie(self, name):
        <span class="PY_STRING">"""Return whether a cookie with the given name exists."""</span>
        <span class="PY_KEYWORD">return</span> name <span class="PY_KEYWORD">in</span> self._cookies

    <span class="PY_KEYWORD">def</span> cookies(self):
        <span class="PY_STRING">"""Return a dict of all cookies the client sent with this request."""</span>
        <span class="PY_KEYWORD">return</span> self._cookies


    <span class="PY_COMMENT">## Variables passed by server ##</span>

    <span class="PY_KEYWORD">def</span> serverDictionary(self):
        <span class="PY_STRING">"""Return a dictionary with the data the web server gave us.

        This data includes HTTP_HOST and HTTP_USER_AGENT, for example.

        """</span>
        <span class="PY_KEYWORD">return</span> self._environ


    <span class="PY_COMMENT">## Sessions ##</span>

    <span class="PY_KEYWORD">def</span> session(self):
        <span class="PY_STRING">"""Return the session associated with this request.

        The session is either as specified by sessionId() or newly created.
        This is a convenience for transaction.session()

        """</span>
        <span class="PY_KEYWORD">return</span> self._transaction.session()

    <span class="PY_KEYWORD">def</span> isSessionExpired(self):
        <span class="PY_STRING">"""Return whether the request originally had an expired session ID.

        Only works if the Application.config setting "IgnoreInvalidSession"
        is set to true; otherwise you get a canned error page on an invalid
        session, so your servlet never gets processed.

        """</span>
        <span class="PY_KEYWORD">return</span> self._sessionExpired

    <span class="PY_KEYWORD">def</span> setSessionExpired(self, sessionExpired):
        self._sessionExpired = sessionExpired


    <span class="PY_COMMENT">## Remote info ##</span>

    <span class="PY_KEYWORD">def</span> remoteUser(self):
        <span class="PY_STRING">"""Always returns None since authentication is not yet supported.

        Take from CGI variable REMOTE_USER.

        """</span>
        <span class="PY_KEYWORD">return</span> self._environ[<span class="PY_STRING">'REMOTE_USER'</span>]

    <span class="PY_KEYWORD">def</span> remoteAddress(self):
        <span class="PY_STRING">"""Return a string containing the IP address of the client."""</span>
        <span class="PY_KEYWORD">return</span> self._environ[<span class="PY_STRING">'REMOTE_ADDR'</span>]

    <span class="PY_KEYWORD">def</span> remoteName(self):
        <span class="PY_STRING">"""Return the fully qualified name of the client that sent the request.

        Returns the IP address of the client if the name cannot be determined.

        """</span>
        env = self._environ
        <span class="PY_KEYWORD">return</span> env.get(<span class="PY_STRING">'REMOTE_NAME'</span>, env[<span class="PY_STRING">'REMOTE_ADDR'</span>])

    <span class="PY_KEYWORD">def</span> accept(self, which=None):
        <span class="PY_STRING">"""Return preferences as requested by the user agent.

        The accepted preferences are returned as a list of codes
        in the same order as they appeared in the header.
        In other words, the explicit weighting criteria are ignored.

        If you do not define otherwise which preferences you are
        interested in ('language', 'charset', 'encoding'), by default
        you will get the user preferences for the content types.

        """</span>
        var = <span class="PY_STRING">'HTTP_ACCEPT'</span>
        <span class="PY_KEYWORD">if</span> which:
            var += <span class="PY_STRING">'_'</span> + which.upper()
        prefs = []
        <span class="PY_KEYWORD">for</span> pref <span class="PY_KEYWORD">in</span> self._environ.get(var, <span class="PY_STRING">''</span>).split(<span class="PY_STRING">','</span>):
            pref = pref.split(<span class="PY_STRING">';'</span>, 1)[0].strip()
            prefs.append(pref)
        <span class="PY_KEYWORD">return</span> prefs


    <span class="PY_COMMENT">## Path ##</span>

    <span class="PY_KEYWORD">def</span> urlPath(self):
        <span class="PY_STRING">"""Return URL path without host, adapter and query string.

        For example, http://host/WebKit.cgi/Context/Servlet?x=1
        yields '/Context/Servlet'.

        If self._absolutepath is set, this refers to the filesystem path.

        """</span>
        <span class="PY_KEYWORD">if</span> self._absolutepath:
            <span class="PY_KEYWORD">return</span> self._fsPath
        <span class="PY_KEYWORD">else</span>:
            <span class="PY_KEYWORD">return</span> self._pathInfo

    <span class="PY_KEYWORD">def</span> urlPathDir(self):
        <span class="PY_STRING">"""Same as urlPath, but only gives the directory."""</span>
        <span class="PY_KEYWORD">return</span> os.path.dirname(self.urlPath())

    <span class="PY_KEYWORD">def</span> setURLPath(self, path):
        <span class="PY_STRING">"""Set the URL path of the request.

        If self._absolutepath is set, this refers to the filesystem path.

        There is rarely a need to do this. Proceed with caution.

        """</span>
        <span class="PY_KEYWORD">if</span> self._absolutepath:
            self._fsPath = path
        <span class="PY_KEYWORD">else</span>:
            self._pathInfo = path
            self._uri = self._servletPath + path
            <span class="PY_KEYWORD">if</span> self._queryString:
                self._uri += <span class="PY_STRING">'?'</span> + self._queryString

    <span class="PY_KEYWORD">def</span> serverSidePath(self, path=None):
        <span class="PY_STRING">"""Return the absolute server-side path of the request.

        If the optional path is passed in, then it is joined with the
        server side directory to form a path relative to the object.

        """</span>
        <span class="PY_KEYWORD">if</span> path:
            <span class="PY_KEYWORD">if</span> path.startswith(<span class="PY_STRING">'/'</span>):
                path = path[1:]
            <span class="PY_KEYWORD">return</span> os.path.normpath(os.path.join(
                os.path.dirname(self._serverSidePath), path))
        <span class="PY_KEYWORD">else</span>:
            <span class="PY_KEYWORD">return</span> self._serverSidePath

    <span class="PY_KEYWORD">def</span> serverSideContextPath(self, path=None):
        <span class="PY_STRING">"""Return the absolute server-side path of the context of this request.

        If the optional path is passed in, then it is joined with the server
        side context directory to form a path relative to the object.

        This directory could be different from the result of serverSidePath()
        if the request is in a subdirectory of the main context directory.

        """</span>
        <span class="PY_KEYWORD">if</span> path:
            <span class="PY_KEYWORD">if</span> path.startswith(<span class="PY_STRING">'/'</span>):
                path = path[1:]
            <span class="PY_KEYWORD">return</span> os.path.normpath(os.path.join(
                self._serverSideContextPath, path))
        <span class="PY_KEYWORD">else</span>:
            <span class="PY_KEYWORD">return</span> self._serverSideContextPath

    <span class="PY_KEYWORD">def</span> contextName(self):
        <span class="PY_STRING">"""Return the name of the context of this request.

        This isn't necessarily the same as the name of the directory
        containing the context.

        """</span>
        <span class="PY_KEYWORD">return</span> self._contextName

    <span class="PY_KEYWORD">def</span> servletURI(self):
        <span class="PY_STRING">"""Return servlet URI without any query strings or extra path info."""</span>
        p = self._pathInfo
        <span class="PY_KEYWORD">if</span> <span class="PY_KEYWORD">not</span> self._extraURLPath:
            <span class="PY_KEYWORD">if</span> p.endswith(<span class="PY_STRING">'/'</span>):
                p = p[:-1]
            <span class="PY_KEYWORD">return</span> p
        i = p.rfind(self._extraURLPath)
        <span class="PY_KEYWORD">if</span> i &gt;= 0:
            p = p[:i]
        <span class="PY_KEYWORD">if</span> p.endswith(<span class="PY_STRING">'/'</span>):
            p = p[:-1]
        <span class="PY_KEYWORD">return</span> p

    <span class="PY_KEYWORD">def</span> uriWebKitRoot(self):
        <span class="PY_STRING">"""Return relative URL path of the WebKit root location."""</span>
        <span class="PY_KEYWORD">if</span> <span class="PY_KEYWORD">not</span> self._serverRootPath:
            self._serverRootPath = <span class="PY_STRING">''</span>
            loc = self.urlPath()
            loc, curr = os.path.split(loc)
            <span class="PY_KEYWORD">while</span> 1:
                loc, curr = os.path.split(loc)
                <span class="PY_KEYWORD">if</span> <span class="PY_KEYWORD">not</span> curr:
                    <span class="PY_KEYWORD">break</span>
                self._serverRootPath += <span class="PY_STRING">"../"</span>
        <span class="PY_KEYWORD">return</span> self._serverRootPath

    <span class="PY_KEYWORD">def</span> fsPath(self):
        <span class="PY_STRING">"""The filesystem path of the request according to the webserver."""</span>
        fspath = self.adapterFileName()
        <span class="PY_KEYWORD">if</span> <span class="PY_KEYWORD">not</span> fspath:
            fspath = self.adapterName()
            docroot = self._environ[<span class="PY_STRING">'DOCUMENT_ROOT'</span>]
            fspath = os.path.join(docroot, fspath)
        <span class="PY_KEYWORD">return</span> fspath

    <span class="PY_KEYWORD">def</span> scheme(self):
        <span class="PY_STRING">"""Return the URI scheme of the request (http or https)."""</span>
        <span class="PY_KEYWORD">return</span> self.isSecure() <span class="PY_KEYWORD">and</span> <span class="PY_STRING">'https'</span> <span class="PY_KEYWORD">or</span> <span class="PY_STRING">'http'</span>

    <span class="PY_KEYWORD">def</span> hostAndPort(self):
        <span class="PY_STRING">"""Return the hostname and port part from the URL of this request."""</span>
        env = self._environ
        <span class="PY_KEYWORD">if</span> <span class="PY_STRING">'HTTP_HOST'</span> <span class="PY_KEYWORD">in</span> env:
            <span class="PY_KEYWORD">return</span> env[<span class="PY_STRING">'HTTP_HOST'</span>]
        <span class="PY_KEYWORD">elif</span> <span class="PY_STRING">'SERVER_NAME'</span> <span class="PY_KEYWORD">in</span> env:
            <span class="PY_KEYWORD">return</span> env[<span class="PY_STRING">'SERVER_NAME'</span>]
        <span class="PY_KEYWORD">else</span>:
            host = env.get(<span class="PY_STRING">'SERVER_ADDR'</span>, <span class="PY_STRING">''</span>) <span class="PY_KEYWORD">or</span> <span class="PY_STRING">'localhost'</span>
            port = env.get(<span class="PY_STRING">'SERVER_PORT'</span>, <span class="PY_STRING">''</span>)
            defaultPort = self.isSecure() <span class="PY_KEYWORD">and</span> <span class="PY_STRING">'443'</span> <span class="PY_KEYWORD">or</span> <span class="PY_STRING">'80'</span>
            <span class="PY_KEYWORD">if</span> port <span class="PY_KEYWORD">and</span> port != defaultPort:
                host += <span class="PY_STRING">':'</span> + port
            <span class="PY_KEYWORD">return</span> host

    <span class="PY_KEYWORD">def</span> serverURL(self, canonical=False):
        <span class="PY_STRING">"""Return the full Internet path to this request.

        This is the URL that was actually received by the webserver
        before any rewriting took place. If canonical is set to true,
        then the canonical hostname of the server is used if possible.

        The path is returned without any extra path info or query strings,
        i.e. http://www.my.own.host.com:8080/WebKit/TestPage.py

        """</span>
        <span class="PY_KEYWORD">if</span> canonical <span class="PY_KEYWORD">and</span> <span class="PY_STRING">'SCRIPT_URI'</span> <span class="PY_KEYWORD">in</span> self._environ:
            <span class="PY_KEYWORD">return</span> self._environ[<span class="PY_STRING">'SCRIPT_URI'</span>]
        <span class="PY_KEYWORD">else</span>:
            <span class="PY_KEYWORD">return</span> <span class="PY_STRING">'%s://%s%s'</span> % (
                self.scheme(), self.hostAndPort(), self.serverPath())

    <span class="PY_KEYWORD">def</span> serverURLDir(self):
        <span class="PY_STRING">"""Return the directory of the URL in full Internet form.

        Same as serverURL, but removes the actual page.

        """</span>
        fullurl = self.serverURL()
        <span class="PY_KEYWORD">if</span> fullurl <span class="PY_KEYWORD">and</span> <span class="PY_KEYWORD">not</span> fullurl.endswith(<span class="PY_STRING">'/'</span>):
            fullurl = fullurl[:fullurl.rfind(<span class="PY_STRING">'/'</span>) + 1]
        <span class="PY_KEYWORD">return</span> fullurl

    <span class="PY_KEYWORD">def</span> serverPath(self):
        <span class="PY_STRING">"""Return the webserver URL path of this request.

        This is the URL that was actually received by the webserver
        before any rewriting took place.

        Same as serverURL, but without scheme and host.

        """</span>
        <span class="PY_KEYWORD">if</span> <span class="PY_STRING">'SCRIPT_URL'</span> <span class="PY_KEYWORD">in</span> self._environ:
            path = self._environ[<span class="PY_STRING">'SCRIPT_URL'</span>]
        <span class="PY_KEYWORD">else</span>:
            path = self._servletPath
            <span class="PY_KEYWORD">if</span> <span class="PY_KEYWORD">not</span> self._absolutepath <span class="PY_KEYWORD">and</span> self._stack:
                path += self._stack[0][1]
            <span class="PY_KEYWORD">else</span>:
                path += self._pathInfo
        <span class="PY_KEYWORD">return</span> path

    <span class="PY_KEYWORD">def</span> serverPathDir(self):
        <span class="PY_STRING">"""Return the directory of the webserver URL path.

        Same as serverPath, but removes the actual page.

        """</span>
        fullurl = self.serverPath()
        <span class="PY_KEYWORD">if</span> fullurl <span class="PY_KEYWORD">and</span> <span class="PY_KEYWORD">not</span> fullurl.endswith(<span class="PY_STRING">'/'</span>):
            fullurl = fullurl[:fullurl.rfind(<span class="PY_STRING">'/'</span>) + 1]
        <span class="PY_KEYWORD">return</span> fullurl

    <span class="PY_KEYWORD">def</span> siteRoot(self):
        <span class="PY_STRING">"""Return the relative URL path of the home location.

        This includes all URL path components necessary to get back home
        from the current location.

        Examples:
            ''
            '../'
            '../../'

        You can use this as a prefix to a URL that you know is based off
        the home location. Any time you are in a servlet that may have been
        forwarded to from another servlet at a different level, you should
        prefix your URL's with this. That is, if servlet "Foo/Bar" forwards
        to "Qux", then the qux servlet should use siteRoot() to construct all
        links to avoid broken links. This works properly because this method
        computes the path based on the _original_ servlet, not the location
        of the servlet that you have forwarded to.

        """</span>
        url = self.originalURLPath()
        <span class="PY_KEYWORD">if</span> url.startswith(<span class="PY_STRING">'/'</span>):
            url = url[1:]
        contextName = self.contextName() + <span class="PY_STRING">'/'</span>
        <span class="PY_KEYWORD">if</span> url.startswith(contextName):
            url = url[len(contextName):]
        numStepsBack = len(url.split(<span class="PY_STRING">'/'</span>)) - 1
        <span class="PY_KEYWORD">return</span> <span class="PY_STRING">'../'</span> * numStepsBack

    <span class="PY_KEYWORD">def</span> siteRootFromCurrentServlet(self):
        <span class="PY_STRING">"""Return relative URL path to home seen from the current servlet.

        This includes all URL path components necessary to get back home
        from the current servlet (not from the original request).

        Similar to siteRoot() but instead, it returns the site root
        relative to the _current_ servlet, not the _original_ servlet.

        """</span>
        url = self.urlPath()
        <span class="PY_KEYWORD">if</span> url.startswith(<span class="PY_STRING">'/'</span>):
            url = url[1:]
        contextName = self.contextName() + <span class="PY_STRING">'/'</span>
        <span class="PY_KEYWORD">if</span> url.startswith(contextName):
            url = url[len(contextName):]
        numStepsBackward = len(url.split(<span class="PY_STRING">'/'</span>)) - 1
        <span class="PY_KEYWORD">return</span> <span class="PY_STRING">'../'</span> * numStepsBackward

    <span class="PY_KEYWORD">def</span> servletPathFromSiteRoot(self):
        <span class="PY_STRING">"""Return the "servlet path" of this servlet relative to the siteRoot.

        In other words, everything after the name of the context (if present).
        If you append this to the result of self.siteRoot() you get back to
        the current servlet. This is useful for saving the path to the current
        servlet in a database, for example.

        """</span>
        urlPath = self.urlPath()
        <span class="PY_KEYWORD">if</span> urlPath.startswith(<span class="PY_STRING">'/'</span>):
            urlPath = urlPath[1:]
        parts = urlPath.split(<span class="PY_STRING">'/'</span>)
        newParts = []
        <span class="PY_KEYWORD">for</span> part <span class="PY_KEYWORD">in</span> parts:
            <span class="PY_KEYWORD">if</span> part == <span class="PY_STRING">'..'</span> <span class="PY_KEYWORD">and</span> newParts:
                newParts.pop()
            <span class="PY_KEYWORD">elif</span> part != <span class="PY_STRING">'.'</span>:
                newParts.append(part)
        <span class="PY_KEYWORD">if</span> newParts[:1] == [self.contextName()]:
            newParts[:1] = []
        <span class="PY_KEYWORD">return</span> <span class="PY_STRING">'/'</span>.join(newParts)


    <span class="PY_COMMENT">## Special ##</span>

    <span class="PY_KEYWORD">def</span> adapterName(self):
        <span class="PY_STRING">"""Return the name of the adapter as it appears in the URL.

        Example: '/WK' or '/WebKit.cgi'
        Does not reflect redirection by the webserver.
        Equivalent to the CGI variable SCRIPT_NAME.

        """</span>
        <span class="PY_KEYWORD">return</span> self._environ.get(<span class="PY_STRING">'SCRIPT_NAME'</span>, <span class="PY_STRING">''</span>)

    <span class="PY_KEYWORD">def</span> adapterFileName(self):
        <span class="PY_STRING">"""Return the filesystem path of the adapter.

        Equivalent to the CGI variable SCRIPT_FILENAME.

        """</span>
        <span class="PY_KEYWORD">return</span> self._environ.get(<span class="PY_STRING">'SCRIPT_FILENAME'</span>, <span class="PY_STRING">''</span>)

    <span class="PY_KEYWORD">def</span> environ(self):
        <span class="PY_STRING">"""Get the environment for the request."""</span>
        <span class="PY_KEYWORD">return</span> self._environ

    <span class="PY_KEYWORD">def</span> push(self, servlet, url=None):
        <span class="PY_STRING">"""Push servlet and URL path on a stack, setting a new URL."""</span>
        self._stack.append((servlet, self.urlPath(), self._contextName,
            self._serverSidePath, self._serverSideContextPath,
            self._serverRootPath, self._extraURLPath))
        <span class="PY_KEYWORD">if</span> url <span class="PY_KEYWORD">is</span> <span class="PY_KEYWORD">not</span> None:
            self.setURLPath(url)

    <span class="PY_KEYWORD">def</span> pop(self):
        <span class="PY_STRING">"""Pop URL path and servlet from the stack, returning the servlet."""</span>
        <span class="PY_KEYWORD">if</span> self._stack:
            (servlet, url, self._contextName,
                self._serverSidePath, self._serverSideContextPath,
                self._serverRootPath, self._extraURLPath) = self._stack.pop()
            <span class="PY_KEYWORD">if</span> url <span class="PY_KEYWORD">is</span> <span class="PY_KEYWORD">not</span> None:
                self.setURLPath(url)
            <span class="PY_KEYWORD">return</span> servlet

    <span class="PY_KEYWORD">def</span> servlet(self):
        <span class="PY_STRING">"""Get current servlet for this request."""</span>
        <span class="PY_KEYWORD">return</span> self._transaction.servlet()

    <span class="PY_KEYWORD">def</span> originalServlet(self):
        <span class="PY_STRING">"""Get original servlet before any forwarding."""</span>
        <span class="PY_KEYWORD">if</span> self._stack:
            <span class="PY_KEYWORD">return</span> self._stack[0][0]
        <span class="PY_KEYWORD">else</span>:
            self.servlet()

    <span class="PY_KEYWORD">def</span> previousServlet(self):
        <span class="PY_STRING">"""Get the servlet that passed this request to us, if any."""</span>
        <span class="PY_KEYWORD">if</span> self._stack:
            <span class="PY_KEYWORD">return</span> self._stack[-1][0]

    parent = previousServlet <span class="PY_COMMENT"># kept old name as synonym</span>

    <span class="PY_KEYWORD">def</span> previousServlets(self):
        <span class="PY_STRING">"""Get the list of all previous servlets."""</span>
        <span class="PY_KEYWORD">return</span> [s[0] <span class="PY_KEYWORD">for</span> s <span class="PY_KEYWORD">in</span> self._stack]

    parents = previousServlets <span class="PY_COMMENT"># kept old name as synonym</span>

    <span class="PY_KEYWORD">def</span> originalURLPath(self):
        <span class="PY_STRING">"""Get URL path of the original servlet before any forwarding."""</span>
        <span class="PY_KEYWORD">if</span> self._stack:
            <span class="PY_KEYWORD">return</span> self._stack[0][1]
        <span class="PY_KEYWORD">else</span>:
            <span class="PY_KEYWORD">return</span> self.urlPath()

    <span class="PY_KEYWORD">def</span> previousURLPath(self):
        <span class="PY_STRING">"""Get the previous URL path, if any."""</span>
        <span class="PY_KEYWORD">if</span> self._stack:
            <span class="PY_KEYWORD">return</span> self._stack[-1][1]

    <span class="PY_KEYWORD">def</span> previousURLPaths(self):
        <span class="PY_STRING">"""Get the list of all previous URL paths."""</span>
        <span class="PY_KEYWORD">return</span> [s[1] <span class="PY_KEYWORD">for</span> s <span class="PY_KEYWORD">in</span> self._stack]

    <span class="PY_KEYWORD">def</span> originalURI(self):
        <span class="PY_STRING">"""Get URI of the original servlet before any forwarding."""</span>
        <span class="PY_KEYWORD">if</span> self._stack:
            <span class="PY_KEYWORD">return</span> self._servletPath + self._stack[0][1]
        <span class="PY_KEYWORD">else</span>:
            <span class="PY_KEYWORD">return</span> self.uri()

    <span class="PY_KEYWORD">def</span> previousURI(self):
        <span class="PY_STRING">"""Get the previous URI, if any."""</span>
        <span class="PY_KEYWORD">if</span> self._stack:
            <span class="PY_KEYWORD">return</span> self._servletPath + self._stack[-1][1]

    <span class="PY_KEYWORD">def</span> previousURIs(self):
        <span class="PY_STRING">"""Get the list of all previous URIs."""</span>
        <span class="PY_KEYWORD">return</span> [self._servletPath + s[1] <span class="PY_KEYWORD">for</span> s <span class="PY_KEYWORD">in</span> self._stack]

    <span class="PY_KEYWORD">def</span> originalContextName(self):
        <span class="PY_STRING">"""Return the name of the original context before any forwarding."""</span>
        <span class="PY_KEYWORD">if</span> self._stack:
            <span class="PY_KEYWORD">return</span> self._stack[0][2]
        <span class="PY_KEYWORD">else</span>:
            <span class="PY_KEYWORD">return</span> self._contextName

    <span class="PY_KEYWORD">def</span> previousContextName(self):
        <span class="PY_STRING">"""Get the previous context name, if any."""</span>
        <span class="PY_KEYWORD">if</span> self._stack:
            <span class="PY_KEYWORD">return</span> self._stack[-1][2]

    <span class="PY_KEYWORD">def</span> previousContextNames(self):
        <span class="PY_STRING">"""Get the list of all previous context names."""</span>
        <span class="PY_KEYWORD">return</span> [s[2] <span class="PY_KEYWORD">for</span> s <span class="PY_KEYWORD">in</span> self._stack]

    <span class="PY_KEYWORD">def</span> rawInput(self, rewind=False):
        <span class="PY_STRING">"""Get the raw input from the request.

        This gives you a file-like object for the data that was sent with
        the request (e.g., the body of a POST request, or the document
        uploaded in a PUT request).

        The file might not be rewound to the beginning if there was valid,
        form-encoded POST data. Pass rewind=True if you want to be sure
        you get the entire body of the request.

        """</span>
        fs = self.fieldStorage()
        <span class="PY_KEYWORD">if</span> fs <span class="PY_KEYWORD">is</span> None:
            <span class="PY_KEYWORD">return</span> None
        <span class="PY_KEYWORD">if</span> rewind <span class="PY_KEYWORD">and</span> fs.file:
            fs.file.seek(0)
        <span class="PY_KEYWORD">return</span> fs.file

    <span class="PY_KEYWORD">def</span> time(self):
        <span class="PY_STRING">"""Return the time that the request was received."""</span>
        <span class="PY_KEYWORD">return</span> self._time

    <span class="PY_KEYWORD">def</span> requestID(self):
        <span class="PY_STRING">"""Return the request ID.

        The request ID is a serial number unique to this request
        (at least unique for one run of the AppServer).

        """</span>
        <span class="PY_KEYWORD">return</span> self._requestID


    <span class="PY_COMMENT">## Information ##</span>

    <span class="PY_KEYWORD">def</span> servletPath(self):
        <span class="PY_STRING">"""Return the base URL for the servlets, sans host.

        This is useful in cases when you are constructing URLs.
        See Testing/Main.py for an example use.

        Roughly equivalent to the CGI variable SCRIPT_NAME,
        but reflects redirection by the webserver.

        """</span>
        <span class="PY_KEYWORD">return</span> self._servletPath

    <span class="PY_KEYWORD">def</span> contextPath(self):
        <span class="PY_STRING">"""Return the portion of the URI that is the context of the request."""</span>
        <span class="PY_KEYWORD">return</span> self._serverSideContextPath

    <span class="PY_KEYWORD">def</span> pathInfo(self):
        <span class="PY_STRING">"""Return any extra path information as sent by the client.

        This is anything after the servlet name but before the query string.
        Equivalent to the CGI variable PATH_INFO.

        """</span>
        <span class="PY_KEYWORD">return</span> self._pathInfo

    <span class="PY_KEYWORD">def</span> pathTranslated(self):
        <span class="PY_STRING">"""Return extra path information translated as file system path.

        This is the same as pathInfo() but translated to the file system.
        Equivalent to the CGI variable PATH_TRANSLATED.

        """</span>
        <span class="PY_KEYWORD">return</span> self._environ.get(<span class="PY_STRING">'PATH_TRANSLATED'</span>, <span class="PY_STRING">''</span>)

    <span class="PY_KEYWORD">def</span> queryString(self):
        <span class="PY_STRING">"""Return the query string portion of the URL for this request.

        Equivalent to the CGI variable QUERY_STRING.

        """</span>
        <span class="PY_KEYWORD">return</span> self._queryString

    <span class="PY_KEYWORD">def</span> uri(self):
        <span class="PY_STRING">"""Return the URI for this request (everything after the host name).

        This is the URL that was actually received by the webserver
        before any rewriting took place, including the query string.
        Equivalent to the CGI variable REQUEST_URI.

        """</span>
        <span class="PY_KEYWORD">return</span> self._uri

    <span class="PY_KEYWORD">def</span> method(self):
        <span class="PY_STRING">"""Return the HTTP request method (in all uppercase).

        Typically from the set GET, POST, PUT, DELETE, OPTIONS and TRACE.

        """</span>
        <span class="PY_KEYWORD">return</span> self._environ[<span class="PY_STRING">'REQUEST_METHOD'</span>].upper()

    <span class="PY_KEYWORD">def</span> sessionId(self):
        <span class="PY_STRING">"""Return a string with the session ID specified by the client.

        Returns None if there is no session ID.

        """</span>
        trans = self._transaction
        app = trans.application()
        sid = self.value(app.sessionName(trans), None)
        <span class="PY_KEYWORD">if</span> app.setting(<span class="PY_STRING">'Debug'</span>)[<span class="PY_STRING">'Sessions'</span>]:
            <span class="PY_KEYWORD">print</span> <span class="PY_STRING">'&gt;&gt; sessionId: returning sid ='</span>, sid
        <span class="PY_KEYWORD">return</span> sid

    <span class="PY_KEYWORD">def</span> setSessionId(self, sessionID, force=False):
        <span class="PY_STRING">"""Set the session ID.

        This needs to be called _before_ attempting to use the session.
        This would be useful if the session ID is being passed in through
        unusual means, for example via a field in an XML-RPC request.

        Pass in force=True if you want to force this session ID to be used
        even if the session doesn't exist. This would be useful in unusual
        circumstances where the client is responsible for creating the unique
        session ID rather than the server.
        Be sure to use only legal filename characters in the session ID --
        0-9, a-z, A-Z, _, -, and . are OK but everything else will be rejected,
        as will identifiers longer than 80 characters.
        (Without passing in force=True, a random session ID will be generated
        if that session ID isn't already present in the session store.)

        """</span>
        <span class="PY_COMMENT"># Modify the request so that it looks like a hashed version of the</span>
        <span class="PY_COMMENT"># given session ID was passed in</span>
        trans = self._transaction
        app = trans.application()
        self.setField(app.sessionName(trans), sessionID)
        <span class="PY_KEYWORD">if</span> force:
            <span class="PY_COMMENT"># Force this session ID to exist, so that a random session ID</span>
            <span class="PY_COMMENT"># won't be created in case it's a new session.</span>
            app.createSessionWithID(trans, sessionID)


    <span class="PY_COMMENT">## Inspection ##</span>

    <span class="PY_KEYWORD">def</span> info(self):
        <span class="PY_STRING">"""Return request info.

        Return a list of tuples where each tuple has a key/label (a string)
        and a value (any kind of object).

        Values are typically atomic values such as numbers and strings or
        another list of tuples in the same fashion. This is for debugging only.

        """</span>
        <span class="PY_COMMENT"># @@ 2000-04-10 ce: implement and invoke super if appropriate</span>
        <span class="PY_COMMENT"># @@ 2002-06-08 ib: should this also return the unparsed body</span>
        <span class="PY_COMMENT"># of the request?</span>
        info = [
            (<span class="PY_STRING">'time'</span>, self._time),
            (<span class="PY_STRING">'environ'</span>, self._environ),
            (<span class="PY_STRING">'input'</span>, self._input),
            (<span class="PY_STRING">'fields'</span>, self._fields),
            (<span class="PY_STRING">'cookies'</span>, self._cookies)
        ]

        <span class="PY_COMMENT"># Information methods</span>
        <span class="PY_KEYWORD">for</span> method <span class="PY_KEYWORD">in</span> _infoMethods:
            <span class="PY_KEYWORD">try</span>:
                info.append((method.__name__, method(self)))
            <span class="PY_KEYWORD">except</span> Exception:
                info.append((method.__name__, None))

        <span class="PY_KEYWORD">return</span> info

    <span class="PY_KEYWORD">def</span> htmlInfo(self):
        <span class="PY_STRING">"""Return a single HTML string that represents info().

        Useful for inspecting objects via web browsers.

        """</span>
        <span class="PY_KEYWORD">return</span> htmlInfo(self.info())

    _exceptionReportAttrNames = Request._exceptionReportAttrNames + (
        <span class="PY_STRING">'uri adapterName servletPath serverSidePath'</span>
        <span class="PY_STRING">' pathInfo pathTranslated queryString method'</span>
        <span class="PY_STRING">' sessionId previousURLPaths fields cookies environ'</span>.split())


<span class="PY_COMMENT">## Info Structure ##</span>

_infoMethods = (
    HTTPRequest.adapterName,
    HTTPRequest.servletPath,
    HTTPRequest.contextPath,
    HTTPRequest.pathInfo,
    HTTPRequest.pathTranslated,
    HTTPRequest.queryString,
    HTTPRequest.uri,
    HTTPRequest.method,
    HTTPRequest.sessionId
)

<span class="PY_KEYWORD">def</span> htmlInfo(info):
    <span class="PY_STRING">"""Return a single HTML string that represents the info structure.

    Useful for inspecting objects via web browsers.

    """</span>
    res = [<span class="PY_STRING">'&lt;table border="1"&gt;\n'</span>]
    <span class="PY_KEYWORD">for</span> pair <span class="PY_KEYWORD">in</span> info:
        value = pair[1]
        <span class="PY_KEYWORD">if</span> hasattr(value, <span class="PY_STRING">'items'</span>) <span class="PY_KEYWORD">and</span> (isinstance(value, dict)
                <span class="PY_KEYWORD">or</span> hasattr(value, <span class="PY_STRING">'__getitem__'</span>)):
            value = htmlInfo(_infoForDict(value))
        res.append(<span class="PY_STRING">'&lt;tr valign="top"&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;\n'</span>
            % (pair[0], value))
    res.append(<span class="PY_STRING">'&lt;/table&gt;\n'</span>)
    <span class="PY_KEYWORD">return</span> <span class="PY_STRING">''</span>.join(res)

<span class="PY_KEYWORD">def</span> _infoForDict(d):
    <span class="PY_STRING">"""Return an "info" structure for any dictionary-like object."""</span>
    <span class="PY_KEYWORD">return</span> sorted(d.items, key=itemgetter(0))
</pre>
<!--footer-->

</body>
</html>
