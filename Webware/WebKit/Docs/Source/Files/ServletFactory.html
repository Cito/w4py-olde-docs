<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>WebKit/ServletFactory.py</title>
<!--css-->

<style type="text/css">
<!--
body{ background: #EEF;
font-family: Verdana, Arial, Helvetica, sans-serif;
font-size: 10pt;
padding: 3pt; }
.PY_KEYWORD{ color: #00C; font-weight: bold; }
.PY_COMMENT{ color: #008; }
.PY_PARAMETER{ color: #C00; }
.PY_IDENTIFIER{ color: #C00; font-weight: bold; }
.PY_STRING{ color: #080; }
-->
</style>
</head>
<body>
<!--header-->

<!--script-->
<pre><span class="PY_STRING">"""Servlet factory template."""</span>

<span class="PY_KEYWORD">import</span> os
<span class="PY_KEYWORD">import</span> sys
<span class="PY_KEYWORD">import</span> threading

<span class="PY_KEYWORD">from</span> keyword <span class="PY_KEYWORD">import</span> iskeyword

<span class="PY_KEYWORD">from</span> MiscUtils <span class="PY_KEYWORD">import</span> AbstractError

<span class="PY_KEYWORD">from</span> Servlet <span class="PY_KEYWORD">import</span> Servlet

debug = False


<span class="PY_KEYWORD">class</span> ServletFactory(object):
    <span class="PY_STRING">"""Servlet factory template.

    ServletFactory is an abstract class that defines the protocol for
    all servlet factories.

    Servlet factories are used by the Application to create servlets
    for transactions.

    A factory must inherit from this class and override uniqueness(),
    extensions() and either loadClass() or servletForTransaction().
    Do not invoke the base class methods as they all raise AbstractErrors.

    Each method is documented below.

    """</span>


    <span class="PY_COMMENT">## Init ##</span>

    <span class="PY_KEYWORD">def</span> __init__(self, application):
        <span class="PY_STRING">"""Create servlet factory.

        Stores a reference to the application in self._app, because
        subclasses may or may not need to talk back to the application
        to do their work.

        """</span>
        self._app = application
        self._imp = self._app._imp
        self._cacheClasses = self._app.setting(<span class="PY_STRING">"CacheServletClasses"</span>, True)
        self._cacheInstances = self._app.setting(<span class="PY_STRING">"CacheServletInstances"</span>, True)
        self._reloadClasses = self._app.setting(<span class="PY_STRING">"ReloadServletClasses"</span>, True)
        <span class="PY_COMMENT"># All caches are keyed on the path.</span>
        <span class="PY_COMMENT"># _classCache caches the servlet classes, in dictionaries</span>
        <span class="PY_COMMENT"># with keys 'mtime' and 'class'.  'mtime' is the</span>
        <span class="PY_COMMENT"># modification time of the enclosing module.</span>
        self._classCache = {}
        <span class="PY_COMMENT"># _servletPool has lists of free reusable servlets</span>
        self._servletPool = {}
        <span class="PY_COMMENT"># _threadsafeServletCache has threadsafe servlets</span>
        <span class="PY_COMMENT"># (which are not pooled, so only one is kept at a time)</span>
        self._threadsafeServletCache = {}
        self._importLock = threading.RLock()


    <span class="PY_COMMENT">## Info ##</span>

    <span class="PY_KEYWORD">def</span> name(self):
        <span class="PY_STRING">"""Return the name of the factory.

        This is a convenience for the class name.

        """</span>
        <span class="PY_KEYWORD">return</span> self.__class__.__name__

    <span class="PY_KEYWORD">def</span> uniqueness(self):
        <span class="PY_STRING">"""Return uniqueness type.

        Returns a string to indicate the uniqueness of the ServletFactory's
        servlets. The Application needs to know if the servlets are unique
        per file, per extension or per application.

        Return values are 'file', 'extension' and 'application'.

        NOTE: Application only supports 'file' uniqueness at this point in time.

        """</span>
        <span class="PY_KEYWORD">raise</span> AbstractError(self.__class__)

    <span class="PY_KEYWORD">def</span> extensions(self):
        <span class="PY_STRING">"""Return a list of extensions that match this handler.

        Extensions should include the dot. An empty string indicates a file
        with no extension and is a valid value. The extension '.*' is a special
        case that is looked for a URL's extension doesn't match anything.

        """</span>
        <span class="PY_KEYWORD">raise</span> AbstractError(self.__class__)


    <span class="PY_COMMENT">## Import ##</span>

    <span class="PY_KEYWORD">def</span> importAsPackage(self, transaction, serverSidePathToImport):
        <span class="PY_STRING">"""Import requested module.

        Imports the module at the given path in the proper package/subpackage
        for the current request. For example, if the transaction has the URL
        http://localhost/WebKit.cgi/MyContextDirectory/MySubdirectory/MyPage
        and path = 'some/random/path/MyModule.py' and the context is configured
        to have the name 'MyContext' then this function imports the module at
        that path as MyContext.MySubdirectory.MyModule . Note that the context
        name may differ from the name of the directory containing the context,
        even though they are usually the same by convention.

        Note that the module imported may have a different name from the
        servlet name specified in the URL. This is used in PSP.

        """</span>

        <span class="PY_COMMENT"># Pull out the full server side path and the context path</span>
        request = transaction.request()
        path = request.serverSidePath()
        contextPath = request.serverSideContextPath()
        fullname = request.contextName()

        <span class="PY_COMMENT"># There is no context, so import the module standalone</span>
        <span class="PY_COMMENT"># and give it a unique name:</span>
        <span class="PY_KEYWORD">if</span> <span class="PY_KEYWORD">not</span> fullname <span class="PY_KEYWORD">or</span> <span class="PY_KEYWORD">not</span> path.startswith(contextPath):
            fullname = serverSidePathToImport
            <span class="PY_KEYWORD">if</span> os.sep != <span class="PY_STRING">'/'</span>:
                fullname = fullname.replace(os.sep, <span class="PY_STRING">'_'</span>)
            fullname = fullname.replace(<span class="PY_STRING">'/'</span>, <span class="PY_STRING">'_'</span>).replace(<span class="PY_STRING">'.'</span>, <span class="PY_STRING">'_'</span>)
            name = os.path.splitext(os.path.basename(
                serverSidePathToImport))[0]
            moduleDir = os.path.dirname(serverSidePathToImport)
            module = self._importModuleFromDirectory(fullname, name,
                moduleDir, forceReload=self._reloadClasses)
            <span class="PY_KEYWORD">return</span> module

        <span class="PY_COMMENT"># First, we'll import the context's package.</span>
        <span class="PY_KEYWORD">if</span> os.sep != <span class="PY_STRING">'/'</span>:
            fullname = fullname.replace(os.sep, <span class="PY_STRING">'_'</span>)
        fullname = fullname.replace(<span class="PY_STRING">'/'</span>, <span class="PY_STRING">'_'</span>)
        directory, contextDirName = os.path.split(contextPath)
        self._importModuleFromDirectory(fullname, contextDirName,
            directory, isPackageDir=True)
        directory = contextPath

        <span class="PY_COMMENT"># Now we'll break up the rest of the path into components.</span>
        remainder = path[len(contextPath)+1:]
        <span class="PY_KEYWORD">if</span> os.sep != <span class="PY_STRING">'/'</span>:
            remainder = remainder.replace(os.sep, <span class="PY_STRING">'/'</span>)
        remainder = remainder.split(<span class="PY_STRING">'/'</span>)

        <span class="PY_COMMENT"># Import all subpackages of the context package</span>
        <span class="PY_KEYWORD">for</span> name <span class="PY_KEYWORD">in</span> remainder[:-1]:
            fullname = <span class="PY_STRING">'%s.%s'</span> % (fullname, name)
            self._importModuleFromDirectory(fullname, name,
                directory, isPackageDir=True)
            directory = os.path.join(directory, name)

        <span class="PY_COMMENT"># Finally, import the module itself as though it was part of the</span>
        <span class="PY_COMMENT"># package or subpackage, even though it may be located somewhere else.</span>
        moduleFileName = os.path.basename(serverSidePathToImport)
        moduleDir = os.path.dirname(serverSidePathToImport)
        name = os.path.splitext(moduleFileName)[0]
        fullname = <span class="PY_STRING">'%s.%s'</span> % (fullname, name)
        module = self._importModuleFromDirectory(fullname, name,
            moduleDir, forceReload=self._reloadClasses)
        <span class="PY_KEYWORD">return</span> module

    <span class="PY_KEYWORD">def</span> _importModuleFromDirectory(self, fullModuleName, moduleName,
            directory, isPackageDir=False, forceReload=False):
        <span class="PY_STRING">"""Imports the given module from the given directory.

        fullModuleName should be the full dotted name that will be given
        to the module within Python. moduleName should be the name of the
        module in the filesystem, which may be different from the name
        given in fullModuleName. Returns the module object. If forceReload is
        True then this reloads the module even if it has already been imported.

        If isPackageDir is True, then this function creates an empty
        __init__.py if that file doesn't already exist.

        """</span>
        <span class="PY_KEYWORD">if</span> debug:
            <span class="PY_KEYWORD">print</span> __file__, fullModuleName, moduleName, directory
        module = sys.modules.get(fullModuleName)
        <span class="PY_KEYWORD">if</span> module <span class="PY_KEYWORD">is</span> <span class="PY_KEYWORD">not</span> None <span class="PY_KEYWORD">and</span> <span class="PY_KEYWORD">not</span> forceReload:
            <span class="PY_KEYWORD">return</span> module
        <span class="PY_KEYWORD">if</span> isPackageDir:
            <span class="PY_COMMENT"># check if __init__.py is in the directory</span>
            packageDir = os.path.join(directory, moduleName)
            initPy = os.path.join(packageDir, <span class="PY_STRING">'__init__.py'</span>)
            <span class="PY_KEYWORD">for</span> ext <span class="PY_KEYWORD">in</span> (<span class="PY_STRING">''</span>, <span class="PY_STRING">'c'</span>, <span class="PY_STRING">'o'</span>):
                <span class="PY_COMMENT"># the __init__.py file may only exist in compiled form</span>
                <span class="PY_KEYWORD">if</span> os.path.exists(initPy + ext):
                    <span class="PY_KEYWORD">break</span>
            <span class="PY_KEYWORD">else</span>: <span class="PY_COMMENT"># if it does not exist, make an empty one</span>
                file = open(initPy, <span class="PY_STRING">'w'</span>)
                file.write(<span class="PY_STRING">'#'</span>)
                file.close()
        fp, pathname, stuff = self._imp.find_module(moduleName, [directory])
        module = self._imp.load_module(fullModuleName, fp, pathname, stuff)
        module.__donotreload__ = self._reloadClasses
        <span class="PY_KEYWORD">return</span> module

    <span class="PY_KEYWORD">def</span> loadClass(self, transaction, path):
        <span class="PY_STRING">"""Load the appropriate class.

        Given a transaction and a path, load the class for creating these
        servlets. Caching, pooling, and threadsafeness are all handled by
        servletForTransaction. This method is not expected to be threadsafe.

        """</span>
        <span class="PY_KEYWORD">raise</span> AbstractError(self.__class__)


    <span class="PY_COMMENT">## Servlet Pool ##</span>

    <span class="PY_KEYWORD">def</span> servletForTransaction(self, transaction):
        <span class="PY_STRING">"""Return a new servlet that will handle the transaction.

        This method handles caching, and will call loadClass(trans, filepath)
        if no cache is found. Caching is generally controlled by servlets
        with the canBeReused() and canBeThreaded() methods.

        """</span>
        request = transaction.request()
        path = request.serverSidePath()
        <span class="PY_COMMENT"># Do we need to import/reimport the class</span>
        <span class="PY_COMMENT"># because the file changed on disk or isn't in cache?</span>
        mtime = os.path.getmtime(path)
        <span class="PY_KEYWORD">if</span> (path <span class="PY_KEYWORD">not</span> <span class="PY_KEYWORD">in</span> self._classCache
                <span class="PY_KEYWORD">or</span> mtime != self._classCache[path][<span class="PY_STRING">'mtime'</span>]):
            <span class="PY_COMMENT"># Use a lock to prevent multiple simultaneous</span>
            <span class="PY_COMMENT"># imports of the same module:</span>
            self._importLock.acquire()
            <span class="PY_KEYWORD">try</span>:
                <span class="PY_KEYWORD">if</span> (path <span class="PY_KEYWORD">not</span> <span class="PY_KEYWORD">in</span> self._classCache
                        <span class="PY_KEYWORD">or</span> mtime != self._classCache[path][<span class="PY_STRING">'mtime'</span>]):
                    theClass = self.loadClass(transaction, path)
                    <span class="PY_KEYWORD">if</span> self._cacheClasses:
                        self._classCache[path] = {
                            <span class="PY_STRING">'mtime'</span>: mtime, <span class="PY_STRING">'class'</span>: theClass}
                <span class="PY_KEYWORD">else</span>:
                    theClass = self._classCache[path][<span class="PY_STRING">'class'</span>]
            <span class="PY_KEYWORD">finally</span>:
                self._importLock.release()
        <span class="PY_KEYWORD">else</span>:
            theClass = self._classCache[path][<span class="PY_STRING">'class'</span>]

        <span class="PY_COMMENT"># Try to find a cached servlet of the correct class.</span>
        <span class="PY_COMMENT"># (Outdated servlets may have been returned to the pool after a new</span>
        <span class="PY_COMMENT"># class was imported, but we don't want to use an outdated servlet.)</span>
        <span class="PY_KEYWORD">if</span> path <span class="PY_KEYWORD">in</span> self._threadsafeServletCache:
            servlet = self._threadsafeServletCache[path]
            <span class="PY_KEYWORD">if</span> servlet.__class__ <span class="PY_KEYWORD">is</span> theClass:
                <span class="PY_KEYWORD">return</span> servlet
        <span class="PY_KEYWORD">else</span>:
            <span class="PY_KEYWORD">while</span> 1:
                <span class="PY_KEYWORD">try</span>:
                    servlet = self._servletPool[path].pop()
                <span class="PY_KEYWORD">except</span> (KeyError, IndexError):
                    <span class="PY_KEYWORD">break</span>
                <span class="PY_KEYWORD">else</span>:
                    <span class="PY_KEYWORD">if</span> servlet.__class__ <span class="PY_KEYWORD">is</span> theClass:
                        servlet.open()
                        <span class="PY_KEYWORD">return</span> servlet

        <span class="PY_COMMENT"># Use a lock to prevent multiple simultaneous imports of the same</span>
        <span class="PY_COMMENT"># module. Note that (only) the import itself is already threadsafe.</span>
        self._importLock.acquire()
        <span class="PY_KEYWORD">try</span>:
            mtime = os.path.getmtime(path)
            <span class="PY_KEYWORD">if</span> path <span class="PY_KEYWORD">not</span> <span class="PY_KEYWORD">in</span> self._classCache:
                self._classCache[path] = {
                    <span class="PY_STRING">'mtime'</span>: mtime,
                    <span class="PY_STRING">'class'</span>: self.loadClass(transaction, path)}
            <span class="PY_KEYWORD">elif</span> mtime &gt; self._classCache[path][<span class="PY_STRING">'mtime'</span>]:
                self._classCache[path][<span class="PY_STRING">'mtime'</span>] = mtime
                self._classCache[path][<span class="PY_STRING">'class'</span>] = self.loadClass(
                    transaction, path)
            theClass = self._classCache[path][<span class="PY_STRING">'class'</span>]
            <span class="PY_KEYWORD">if</span> <span class="PY_KEYWORD">not</span> self._cacheClasses:
                <span class="PY_KEYWORD">del</span> self._classCache[path]
        <span class="PY_KEYWORD">finally</span>:
            self._importLock.release()

        <span class="PY_COMMENT"># No adequate cached servlet exists, so create a new servlet instance</span>
        servlet = theClass()
        servlet.setFactory(self)
        <span class="PY_KEYWORD">if</span> servlet.canBeReused():
            <span class="PY_KEYWORD">if</span> servlet.canBeThreaded():
                self._threadsafeServletCache[path] = servlet
            <span class="PY_KEYWORD">else</span>:
                self._servletPool[path] = []
                servlet.open()
        <span class="PY_KEYWORD">return</span> servlet

    <span class="PY_KEYWORD">def</span> returnServlet(self, servlet):
        <span class="PY_STRING">"""Return servlet to the pool.

        Called by Servlet.close(), which returns the servlet
        to the servlet pool if necessary.

        """</span>
        <span class="PY_KEYWORD">if</span> (servlet.canBeReused() <span class="PY_KEYWORD">and</span> <span class="PY_KEYWORD">not</span> servlet.canBeThreaded()
                <span class="PY_KEYWORD">and</span> self._cacheInstances):
            path = servlet.serverSidePath()
            self._servletPool[path].append(servlet)

    <span class="PY_KEYWORD">def</span> flushCache(self):
        <span class="PY_STRING">"""Flush the servlet cache and start fresh.

        Servlets that are currently in the wild may find their way back
        into the cache (this may be a problem).

        """</span>
        self._importLock.acquire()
        self._classCache = {}
        <span class="PY_COMMENT"># We can't just delete all the lists, because returning</span>
        <span class="PY_COMMENT"># servlets expect it to exist.</span>
        <span class="PY_KEYWORD">for</span> key <span class="PY_KEYWORD">in</span> self._servletPool:
            self._servletPool[key] = []
        self._threadsafeServletCache = {}
        self._importLock.release()


<span class="PY_KEYWORD">class</span> PythonServletFactory(ServletFactory):
    <span class="PY_STRING">"""The factory for Python servlets.

    This is the factory for ordinary Python servlets whose extensions
    are empty or .py. The servlets are unique per file since the file
    itself defines the servlet.

    """</span>


    <span class="PY_COMMENT">## Info ##</span>

    <span class="PY_KEYWORD">def</span> uniqueness(self):
        <span class="PY_KEYWORD">return</span> <span class="PY_STRING">'file'</span>

    <span class="PY_KEYWORD">def</span> extensions(self):
        <span class="PY_COMMENT"># The extensions of ordinary Python servlets. Besides .py, we also</span>
        <span class="PY_COMMENT"># allow .pyc and .pyo files as Python servlets, so you can use</span>
        <span class="PY_COMMENT"># servlets in the production environment without the source code.</span>
        <span class="PY_COMMENT"># Otherwise they would be treated as ordinary files which might</span>
        <span class="PY_COMMENT"># become a security hole (though the standard configuration ignores</span>
        <span class="PY_COMMENT"># the .pyc and .pyo files). If you use all of them, make sure .py</span>
        <span class="PY_COMMENT"># comes before .pyc and .pyo in the ExtensionCascadeOrder.</span>
        <span class="PY_KEYWORD">return</span> [<span class="PY_STRING">'.py'</span>, <span class="PY_STRING">'.pyc'</span>, <span class="PY_STRING">'.pyo'</span>]


    <span class="PY_COMMENT">## Import ##</span>

    <span class="PY_KEYWORD">def</span> loadClass(self, transaction, path):
        <span class="PY_COMMENT"># Import the module as part of the context's package</span>
        module = self.importAsPackage(transaction, path)

        <span class="PY_COMMENT"># The class name is expected to be the same as the servlet name:</span>
        name = os.path.splitext(os.path.split(path)[1])[0]
        <span class="PY_COMMENT"># Check whether such a class exists in the servlet module:</span>
        <span class="PY_KEYWORD">if</span> <span class="PY_KEYWORD">not</span> hasattr(module, name):
            <span class="PY_COMMENT"># If it does not exist, maybe the name has to be mangled.</span>
            <span class="PY_COMMENT"># Servlet names may have dashes or blanks in them, but classes not.</span>
            <span class="PY_COMMENT"># So we automatically translate dashes blanks to underscores:</span>
            name = name.replace(<span class="PY_STRING">'-'</span>, <span class="PY_STRING">'_'</span>).replace(<span class="PY_STRING">' '</span>, <span class="PY_STRING">'_'</span>)
            <span class="PY_COMMENT"># You may also have a servlet name that is a Python reserved word.</span>
            <span class="PY_COMMENT"># Automatically append an underscore in these cases:</span>
            <span class="PY_KEYWORD">if</span> iskeyword(name):
                name += <span class="PY_STRING">'_'</span>
            <span class="PY_COMMENT"># If the mangled name does not exist either, report an error:</span>
            <span class="PY_KEYWORD">if</span> <span class="PY_KEYWORD">not</span> hasattr(module, name):
                <span class="PY_KEYWORD">raise</span> ValueError(<span class="PY_STRING">'Cannot find expected servlet class %r in %r.'</span>
                    % (name, path))
        <span class="PY_COMMENT"># Pull the servlet class out of the module:</span>
        theClass = getattr(module, name)
        <span class="PY_KEYWORD">assert</span> isinstance(theClass, (object, type))
        <span class="PY_KEYWORD">assert</span> issubclass(theClass, Servlet)
        <span class="PY_KEYWORD">return</span> theClass
</pre>
<!--footer-->

</body>
</html>
