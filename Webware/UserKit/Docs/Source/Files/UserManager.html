<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>UserKit/UserManager.py</title>
<!--css-->

<style type="text/css">
<!--
body{ background: #EEF;
font-family: Verdana, Arial, Helvetica, sans-serif;
font-size: 10pt;
padding: 3pt; }
.PY_KEYWORD{ color: #00C; font-weight: bold; }
.PY_COMMENT{ color: #008; }
.PY_PARAMETER{ color: #C00; }
.PY_IDENTIFIER{ color: #C00; font-weight: bold; }
.PY_STRING{ color: #080; }
-->
</style>
</head>
<body>
<!--header-->

<!--script-->
<pre><span class="PY_STRING">"""The abstract UserManager class."""</span>

<span class="PY_KEYWORD">from</span> MiscUtils <span class="PY_KEYWORD">import</span> AbstractError, NoDefault
<span class="PY_KEYWORD">from</span> User <span class="PY_KEYWORD">import</span> User


<span class="PY_KEYWORD">class</span> UserManager(object):
    <span class="PY_STRING">"""The base class for all user manager classes.

    A UserManager manages a set of users including authentication,
    indexing and persistence. Keep in mind that UserManager is abstract;
    you will always use one of the concrete subclasses (but please read
    the rest of this docstring):
      * UserManagerToFile
      * UserManagerToMiddleKit

    You can create a user through the manager (preferred):
        user = manager.createUser(name, password)

    Or directly through the user class:
        user = RoleUser(manager, name, password)
        manager.addUser(user)

    The manager tracks users by whether or not they are "active"
    (e.g., logged in) and indexes them by:
      * user serial number
      * external user id
      * user name

    These methods provide access to the users by these keys:
        def userForSerialNum(self, serialNum, default=NoDefault)
        def userForExternalId(self, extId, default=NoDefault)
        def userForName(self, name, default=NoDefault)

    UserManager provides convenient methods for iterating through the
    various users. Each method returns an object that can be used in a
    for loop and asked for its len():
        def users(self)
        def activeUsers(self)
        def inactiveUsers(self)

    You can authenticate a user by passing the user object and attempted
    password to login(). If the authentication is successful, then login()
    returns the User, otherwise it returns None:
        user = mgr.userForExternalId(externalId)
        if mgr.login(user, password):
            self.doSomething()

    As a convenience, you can authenticate by passing the serialNum,
    externalId or name of the user:
        def loginSerialNum(self, serialNum, password):
        def loginExternalId(self, externalId, password):
        def loginName(self, userName, password):

    The user will automatically log out after a period of inactivity
    (see below), or you can make it happen with:
        def logout(self, user):

    There are three user states that are important to the manager:
      * modified
      * cached
      * authenticated or "active"

    A modified user is one whose data has changed and eventually requires
    storage to a persistent location. A cached user is a user whose data
    resides in memory (regardless of the other states). An active user
    has been authenticated (e.g., their username and password were checked)
    and has not yet logged out or timed out.

    The manager keeps three timeouts, expressed in minutes, to:
      * save modified users after a period of time following the first
        unsaved modification
      * push users out of memory after a period of inactivity
      * deactive (e.g., log out) users after a period of inactivity

    The methods for managing these values deal with the timeouts as
    number-of-minutes. The default values and the methods are:
      * 20  modifiedUserTimeout()  setModifiedUserTimeout()
      * 20  cachedUserTimeout()    setCachedUserTimeout()
      * 20  activeUserTimeout()    setActiveUserTimeout()

    Subclasses of UserManager provide persistence such as to the file
    system or a MiddleKit store. Subclasses must implement all methods
    that raise AbstractError's. Subclasses typically override (while still
    invoking super) addUser().

    Subclasses should ensure "uniqueness" of users. For example, invoking
    any of the userForSomething() methods repeatedly should always return
    the same user instance for a given key. Without uniqueness, consistency
    issues could arise with users that are modified.

    Please read the method docstrings and other class documentation to
    fully understand UserKit.

    """</span>


    <span class="PY_COMMENT">## Init ##</span>

    <span class="PY_KEYWORD">def</span> __init__(self, userClass=None):
        <span class="PY_KEYWORD">if</span> userClass <span class="PY_KEYWORD">is</span> None:
            self._userClass = None
        <span class="PY_KEYWORD">else</span>:
            self.setUserClass(userClass)
        self._cachedUsers = []
        self._cachedUsersBySerialNum = {}
        self.setModifiedUserTimeout(20)
        self.setCachedUserTimeout(20)
        self.setActiveUserTimeout(20)
        self._numActive = 0

    <span class="PY_KEYWORD">def</span> shutDown(self):
        <span class="PY_STRING">"""Perform any tasks necessary to shut down the user manager.

        Subclasses may override and must invoke super as their *last* step.

        """</span>
        <span class="PY_KEYWORD">pass</span>


    <span class="PY_COMMENT">## Settings ##</span>

    <span class="PY_KEYWORD">def</span> userClass(self):
        <span class="PY_STRING">"""Return the userClass, which is used by createUser.

        The default value is UserKit.User.User.

        """</span>
        <span class="PY_KEYWORD">if</span> self._userClass <span class="PY_KEYWORD">is</span> None:
            self.setUserClass(User)
        <span class="PY_KEYWORD">return</span> self._userClass

    <span class="PY_KEYWORD">def</span> setUserClass(self, userClass):
        <span class="PY_STRING">"""Set the userClass, which cannot be None and must inherit from User.

        See also: userClass().

        """</span>
        <span class="PY_KEYWORD">assert</span> issubclass(userClass, User)
        self._userClass = userClass

    <span class="PY_KEYWORD">def</span> modifiedUserTimeout(self):
        <span class="PY_KEYWORD">return</span> self._modifiedUserTimeout

    <span class="PY_KEYWORD">def</span> setModifiedUserTimeout(self, value):
        self._modifiedUserTimeout = value

    <span class="PY_KEYWORD">def</span> cachedUserTimeout(self):
        <span class="PY_KEYWORD">return</span> self._cachedUserTimeout

    <span class="PY_KEYWORD">def</span> setCachedUserTimeout(self, value):
        self._cachedUserTimeout = value

    <span class="PY_KEYWORD">def</span> activeUserTimeout(self):
        <span class="PY_KEYWORD">return</span> self._activeUserTimeout

    <span class="PY_KEYWORD">def</span> setActiveUserTimeout(self, value):
        self._activeUserTimeout = value


    <span class="PY_COMMENT">## Basic user access ##</span>

    <span class="PY_KEYWORD">def</span> createUser(self, name, password, userClass=None):
        <span class="PY_STRING">"""Return a newly created user that is added to the manager.

        If userClass is not specified, the manager's default user class
        is instantiated. This not imply that the user is logged in.
        This method invokes self.addUser().

        See also: userClass(), setUserClass()

        """</span>
        <span class="PY_KEYWORD">if</span> userClass <span class="PY_KEYWORD">is</span> None:
            userClass = self.userClass()
        user = userClass(manager=self, name=name, password=password)
        self.addUser(user)
        <span class="PY_KEYWORD">return</span> user

    <span class="PY_KEYWORD">def</span> addUser(self, user):
        <span class="PY_KEYWORD">assert</span> isinstance(user, User)
        self._cachedUsers.append(user)
        <span class="PY_KEYWORD">assert</span> user.serialNum() <span class="PY_KEYWORD">not</span> <span class="PY_KEYWORD">in</span> self._cachedUsersBySerialNum
        self._cachedUsersBySerialNum[user.serialNum()] = user

    <span class="PY_KEYWORD">def</span> userForSerialNum(self, serialNum, default=NoDefault):
        <span class="PY_STRING">"""Return the user with the given serialNum.

        The user record is pulled into memory if needed.

        """</span>
        <span class="PY_KEYWORD">raise</span> AbstractError(self.__class__)

    <span class="PY_KEYWORD">def</span> userForExternalId(self, externalId, default=NoDefault):
        <span class="PY_STRING">"""Return the user with the given external id.

        The user record is pulled into memory if needed.

        """</span>
        <span class="PY_KEYWORD">raise</span> AbstractError(self.__class__)

    <span class="PY_KEYWORD">def</span> userForName(self, name, default=NoDefault):
        <span class="PY_STRING">"""Return the user with the given name.

        The user record is pulled into memory if needed.

        """</span>
        <span class="PY_KEYWORD">raise</span> AbstractError(self.__class__)

    <span class="PY_KEYWORD">def</span> users(self):
        <span class="PY_STRING">"""Return a list of all users (regardless of login status)."""</span>
        <span class="PY_KEYWORD">raise</span> AbstractError(self.__class__)

    <span class="PY_KEYWORD">def</span> numActiveUsers(self):
        <span class="PY_STRING">"""Return the number of active users, e.g., users that are logged in."""</span>
        <span class="PY_KEYWORD">return</span> self._numActive

    <span class="PY_KEYWORD">def</span> activeUsers(self):
        <span class="PY_STRING">"""Return a list of all active users."""</span>
        <span class="PY_KEYWORD">raise</span> AbstractError(self.__class__)

    <span class="PY_KEYWORD">def</span> inactiveUsers(self):
        <span class="PY_KEYWORD">raise</span> AbstractError(self.__class__)


    <span class="PY_COMMENT">## Logging in and out ##</span>

    <span class="PY_KEYWORD">def</span> login(self, user, password):
        <span class="PY_STRING">"""Return the user if the login is successful, otherwise return None."""</span>
        <span class="PY_KEYWORD">assert</span> isinstance(user, User)
        result = user.login(password, fromMgr=True)
        <span class="PY_KEYWORD">if</span> result:
            self._numActive += 1
        <span class="PY_KEYWORD">return</span> result

    <span class="PY_KEYWORD">def</span> logout(self, user):
        <span class="PY_KEYWORD">assert</span> isinstance(user, User)
        user.logout(fromMgr=True)
        self._numActive -= 1

    <span class="PY_KEYWORD">def</span> loginSerialNum(self, serialNum, password):
        user = self.userForSerialNum(serialNum, None)
        <span class="PY_KEYWORD">if</span> user:
            <span class="PY_KEYWORD">return</span> self.login(user, password)
        <span class="PY_KEYWORD">else</span>:
            <span class="PY_KEYWORD">return</span> None

    <span class="PY_KEYWORD">def</span> loginExternalId(self, externalId, password):
        user = self.userForExternalId(externalId, None)
        <span class="PY_KEYWORD">if</span> user:
            <span class="PY_KEYWORD">return</span> self.login(user, password)
        <span class="PY_KEYWORD">else</span>:
            <span class="PY_KEYWORD">return</span> None

    <span class="PY_KEYWORD">def</span> loginName(self, userName, password):
        user = self.userForName(userName, None)
        <span class="PY_KEYWORD">if</span> user:
            <span class="PY_KEYWORD">return</span> self.login(user, password)
        <span class="PY_KEYWORD">else</span>:
            <span class="PY_KEYWORD">return</span> None


    <span class="PY_COMMENT">## Cached ##</span>

    <span class="PY_KEYWORD">def</span> clearCache(self):
        <span class="PY_STRING">"""Clear the cache of the manager.

        Use with extreme caution. If your program maintains a reference
        to a user object, but the manager loads in a new copy later on,
        then consistency problems could occur.

        The most popular use of this method is in the regression test suite.

        """</span>
        self._cachedUsers = []
        self._cachedUsersBySerialNum = {}
</pre>
<!--footer-->

</body>
</html>
