<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>DBUtils/SimplePooledDB.py</title>
<!--css-->

<style type="text/css">
<!--
body{ background: #EEF;
font-family: Verdana, Arial, Helvetica, sans-serif;
font-size: 10pt;
padding: 3pt; }
.PY_KEYWORD{ color: #00C; font-weight: bold; }
.PY_COMMENT{ color: #008; }
.PY_PARAMETER{ color: #C00; }
.PY_IDENTIFIER{ color: #C00; font-weight: bold; }
.PY_STRING{ color: #080; }
-->
</style>
</head>
<body>
<!--header-->

<!--script-->
<pre><span class="PY_STRING">"""SimplePooledDB - a very simple DB-API 2 database connection pool.

Implements a pool of threadsafe cached DB-API 2 connections
to a database which are transparently reused.

This should result in a speedup for persistent applications
such as the "Webware for Python" AppServer.

For more information on the DB-API 2, see:
    http://www.python.org/peps/pep-0249.html
For more information on Webware for Python, see:
    http://www.webwareforpython.org

Measures are taken to make the pool of connections threadsafe
regardless of whether the DB-API 2 module used is threadsafe
on the connection level (threadsafety &gt; 1) or not. It must only
be threadsafe on the module level (threadsafety = 1). If the
DB-API 2 module is threadsafe, the connections will be shared
between threads (keep this in mind if you use transactions).

Usage:

The idea behind SimplePooledDB is that it's completely transparent.
After you have established your connection pool, stating the
DB-API 2 module to be used, the number of connections
to be cached in the pool and the connection parameters, e.g.

    import pgdb # import used DB-API 2 module
    from DBUtils.SimplePooledDB import PooledDB
    dbpool = PooledDB(pgdb, 5, host=..., database=..., user=..., ...)

you can demand database connections from that pool,

    db = dbpool.connection()

and use them just as if they were ordinary DB-API 2 connections.
It's really just a proxy class.

db.close() will return the connection to the pool, it will not
actually close it. This is so your existing code works nicely.

Ideas for improvement:

* Do not create the maximum number of connections on startup
already, but only a certain number and the rest on demand.
* Detect and transparently reset "bad" connections.
* Connections should have some sort of maximum usage limit
after which they should be automatically closed and reopened.
* Prefer or enforce thread-affinity for the connections,
allowing for both sharable and non-sharable connections.

Please note that these and other ideas have been already
implemented in in PooledDB, a more sophisticated version
of SimplePooledDB. You might also consider using PersistentDB
instead for thread-affine persistent database connections.
SimplePooledDB may still serve as a very simple reference
and example implementation for developers.


Copyright, credits and license:

* Contributed as MiscUtils/DBPool for Webware for Python
  by Dan Green, December 2000
* Thread safety bug found by Tom Schwaller
* Fixes by Geoff Talvola (thread safety in _threadsafe_getConnection())
* Clean up by Chuck Esterbrook
* Fix unthreadsafe functions which were leaking, Jay Love
* Eli Green's webware-discuss comments were lifted for additional docs
* Clean-up and detailed commenting, rename and move to DBUtils
  by Christoph Zwerschke in September 2005

Licensed under the Open Software License version 2.1.

"""</span>

__version__ = <span class="PY_STRING">'1.1'</span>
__revision__ = <span class="PY_STRING">"$Rev: 8218 $"</span>
__date__ = <span class="PY_STRING">"$Date: 2011-08-14 13:57:11 +0200 (So, 14. Aug 2011) $"</span>


<span class="PY_KEYWORD">class</span> PooledDBError(Exception):
    <span class="PY_STRING">"""General PooledDB error."""</span>

<span class="PY_KEYWORD">class</span> NotSupportedError(PooledDBError):
    <span class="PY_STRING">"""DB-API module not supported by PooledDB."""</span>


<span class="PY_KEYWORD">class</span> PooledDBConnection:
    <span class="PY_STRING">"""A proxy class for pooled database connections.

    You don't normally deal with this class directly,
    but use PooledDB to get new connections.

    """</span>

    <span class="PY_KEYWORD">def</span> __init__(self, pool, con):
        self._con = con
        self._pool = pool

    <span class="PY_KEYWORD">def</span> close(self):
        <span class="PY_STRING">"""Close the pooled connection."""</span>
        <span class="PY_COMMENT"># Instead of actually closing the connection,</span>
        <span class="PY_COMMENT"># return it to the pool so it can be reused.</span>
        <span class="PY_KEYWORD">if</span> self._con <span class="PY_KEYWORD">is</span> <span class="PY_KEYWORD">not</span> None:
            self._pool.returnConnection(self._con)
            self._con = None

    <span class="PY_KEYWORD">def</span> __getattr__(self, name):
        <span class="PY_COMMENT"># All other members are the same.</span>
        <span class="PY_KEYWORD">return</span> getattr(self._con, name)

    <span class="PY_KEYWORD">def</span> __del__(self):
        self.close()


<span class="PY_KEYWORD">class</span> PooledDB:
    <span class="PY_STRING">"""A very simple database connection pool.

    After you have created the connection pool,
    you can get connections using getConnection().

    """</span>

    version = __version__

    <span class="PY_KEYWORD">def</span> __init__(self, dbapi, maxconnections, *args, **kwargs):
        <span class="PY_STRING">"""Set up the database connection pool.

        dbapi: the DB-API 2 compliant module you want to use
        maxconnections: the number of connections cached in the pool
        args, kwargs: the parameters that shall be used to establish
            the database connections using connect()

        """</span>
        <span class="PY_KEYWORD">try</span>:
            threadsafety = dbapi.threadsafety
        <span class="PY_KEYWORD">except</span> Exception:
            threadsafety = None
        <span class="PY_KEYWORD">if</span> threadsafety == 0:
            <span class="PY_KEYWORD">raise</span> NotSupportedError(
                <span class="PY_STRING">"Database module does not support any level of threading."</span>)
        <span class="PY_KEYWORD">elif</span> threadsafety == 1:
            <span class="PY_COMMENT"># If there is no connection level safety, build</span>
            <span class="PY_COMMENT"># the pool using the synchronized queue class</span>
            <span class="PY_COMMENT"># that implements all the required locking semantics.</span>
            <span class="PY_KEYWORD">from</span> Queue <span class="PY_KEYWORD">import</span> Queue
            self._queue = Queue(maxconnections) <span class="PY_COMMENT"># create the queue</span>
            self.connection = self._unthreadsafe_get_connection
            self.addConnection = self._unthreadsafe_add_connection
            self.returnConnection = self._unthreadsafe_return_connection
        <span class="PY_KEYWORD">elif</span> threadsafety <span class="PY_KEYWORD">in</span> (2, 3):
            <span class="PY_COMMENT"># If there is connection level safety, implement the</span>
            <span class="PY_COMMENT"># pool with an ordinary list used as a circular buffer.</span>
            <span class="PY_COMMENT"># We only need a minimum of locking in this case.</span>
            <span class="PY_KEYWORD">from</span> threading <span class="PY_KEYWORD">import</span> Lock
            self._lock = Lock() <span class="PY_COMMENT"># create a lock object to be used later</span>
            self._nextConnection = 0 <span class="PY_COMMENT"># index of the next connection to be used</span>
            self._connections = [] <span class="PY_COMMENT"># the list of connections</span>
            self.connection = self._threadsafe_get_connection
            self.addConnection = self._threadsafe_add_connection
            self.returnConnection = self._threadsafe_return_connection
        <span class="PY_KEYWORD">else</span>:
            <span class="PY_KEYWORD">raise</span> NotSupportedError(
                <span class="PY_STRING">"Database module threading support cannot be determined."</span>)
        <span class="PY_COMMENT"># Establish all database connections (it would be better to</span>
        <span class="PY_COMMENT"># only establish a part of them now, and the rest on demand).</span>
        <span class="PY_KEYWORD">for</span> i <span class="PY_KEYWORD">in</span> range(maxconnections):
            self.addConnection(dbapi.connect(*args, **kwargs))

    <span class="PY_COMMENT"># The following functions are used with DB-API 2 modules</span>
    <span class="PY_COMMENT"># that do not have connection level threadsafety, like PyGreSQL.</span>
    <span class="PY_COMMENT"># However, the module must be threadsafe at the module level.</span>
    <span class="PY_COMMENT"># Note: threadsafe/unthreadsafe refers to the DB-API 2 module,</span>
    <span class="PY_COMMENT"># not to this class which should be threadsafe in any case.</span>

    <span class="PY_KEYWORD">def</span> _unthreadsafe_get_connection(self):
        <span class="PY_STRING">"""Get a connection from the pool."""</span>
        <span class="PY_KEYWORD">return</span> PooledDBConnection(self, self._queue.get())

    <span class="PY_KEYWORD">def</span> _unthreadsafe_add_connection(self, con):
        <span class="PY_STRING">"""Add a connection to the pool."""</span>
        self._queue.put(con)

    <span class="PY_KEYWORD">def</span> _unthreadsafe_return_connection(self, con):
        <span class="PY_STRING">"""Return a connection to the pool.

        In this case, the connections need to be put
        back into the queue after they have been used.
        This is done automatically when the connection is closed
        and should never be called explicitly outside of this module.

        """</span>
        self._unthreadsafe_add_connection(con)

    <span class="PY_COMMENT"># The following functions are used with DB-API 2 modules</span>
    <span class="PY_COMMENT"># that are threadsafe at the connection level, like psycopg.</span>
    <span class="PY_COMMENT"># Note: In this case, connections are shared between threads.</span>
    <span class="PY_COMMENT"># This may lead to problems if you use transactions.</span>

    <span class="PY_KEYWORD">def</span> _threadsafe_get_connection(self):
        <span class="PY_STRING">"""Get a connection from the pool."""</span>
        self._lock.acquire()
        <span class="PY_KEYWORD">try</span>:
            next = self._nextConnection
            con = PooledDBConnection(self, self._connections[next])
            next += 1
            <span class="PY_KEYWORD">if</span> next &gt;= len(self._connections):
                next = 0
            self._nextConnection = next
            <span class="PY_KEYWORD">return</span> con
        <span class="PY_KEYWORD">finally</span>:
            self._lock.release()

    <span class="PY_KEYWORD">def</span> _threadsafe_add_connection(self, con):
        <span class="PY_STRING">"""Add a connection to the pool."""</span>
        self._connections.append(con)

    <span class="PY_KEYWORD">def</span> _threadsafe_return_connection(self, con):
        <span class="PY_STRING">"""Return a connection to the pool.

        In this case, the connections always stay in the pool,
        so there is no need to do anything here.

        """</span>
        <span class="PY_KEYWORD">pass</span>
</pre>
<!--footer-->

</body>
</html>
