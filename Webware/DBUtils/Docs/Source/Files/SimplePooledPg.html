<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>DBUtils/SimplePooledPg.py</title>
<!--css-->

<style type="text/css">
<!--
body{ background: #EEF;
font-family: Verdana, Arial, Helvetica, sans-serif;
font-size: 10pt;
padding: 3pt; }
.PY_KEYWORD{ color: #00C; font-weight: bold; }
.PY_COMMENT{ color: #008; }
.PY_PARAMETER{ color: #C00; }
.PY_IDENTIFIER{ color: #C00; font-weight: bold; }
.PY_STRING{ color: #080; }
-->
</style>
</head>
<body>
<!--header-->

<!--script-->
<pre><span class="PY_STRING">"""SimplePooledPg - a very simple classic PyGreSQL connection pool.

Implements a pool of threadsafe cached connections
to a PostgreSQL database which are transparently reused,
using the classic (not DB-API 2 compliant) PyGreSQL pg API.

This should result in a speedup for persistent applications
such as the "Webware for Python" AppServer.

For more information on PostgreSQL, see:
    http://www.postgresql.org
For more information on PyGreSQL, see:
    http://www.pygresql.org
For more information on Webware for Python, see:
    http://www.webwareforpython.org

Measures are taken to make the pool of connections threadsafe
regardless of the fact that the PyGreSQL pg module itself is
not threadsafe at the connection level. Connections will never be
shared between threads, so you can safely use transactions.

Usage:

The idea behind SimplePooledPg is that it's completely transparent.
After you have established your connection pool, stating the
number of connections to be cached in the pool and the
connection parameters, e.g.

    from DBUtils.SimplePooledPg import PooledPg
    dbpool = PooledPg(5, host=..., database=..., user=..., ...)

you can demand database connections from that pool,

    db = dbpool.connection()

and use them just as if they were ordinary PyGreSQL pg API
connections. It's really just a proxy class.

db.close() will return the connection to the pool, it will not
actually close it. This is so your existing code works nicely.

Ideas for improvement:

* Do not create the maximum number of connections on startup
already, but only a certain number and the rest on demand.
* Detect and transparently reset "bad" connections. The PyGreSQL
pg API provides a status attribute and a reset() method for that.
* Connections should have some sort of "maximum usage limit"
after which they should be automatically closed and reopened.
* Prefer or enforce thread affinity for the connections.

Please note that these and other ideas have been already
implemented in in PooledPg, a more sophisticated version
of SimplePooledPg. You might also consider using PersistentPg
instead for thread-affine persistent PyGreSQL connections.
SimplePooledPg may still serve as a very simple reference
and example implementation for developers.


Copyright, credits and license:

* Contributed as supplement for Webware for Python and PyGreSQL
  by Christoph Zwerschke in September 2005
* Based on the code of DBPool, contributed to Webware for Python
  by Dan Green in December 2000

Licensed under the Open Software License version 2.1.

"""</span>

__version__ = <span class="PY_STRING">'1.1'</span>
__revision__ = <span class="PY_STRING">"$Rev: 8218 $"</span>
__date__ = <span class="PY_STRING">"$Date: 2011-08-14 13:57:11 +0200 (So, 14. Aug 2011) $"</span>


<span class="PY_KEYWORD">from</span> pg <span class="PY_KEYWORD">import</span> DB <span class="PY_KEYWORD">as</span> PgConnection


<span class="PY_KEYWORD">class</span> PooledPgConnection:
    <span class="PY_STRING">"""A proxy class for pooled PostgreSQL connections.

    You don't normally deal with this class directly,
    but use PooledPg to get new connections.

    """</span>

    <span class="PY_KEYWORD">def</span> __init__(self, pool, con):
        self._con = con
        self._pool = pool

    <span class="PY_KEYWORD">def</span> close(self):
        <span class="PY_STRING">"""Close the pooled connection."""</span>
        <span class="PY_COMMENT"># Instead of actually closing the connection,</span>
        <span class="PY_COMMENT"># return it to the pool so it can be reused.</span>
        <span class="PY_KEYWORD">if</span> self._con <span class="PY_KEYWORD">is</span> <span class="PY_KEYWORD">not</span> None:
            self._pool.cache(self._con)
            self._con = None

    <span class="PY_KEYWORD">def</span> __getattr__(self, name):
        <span class="PY_COMMENT"># All other members are the same.</span>
        <span class="PY_KEYWORD">return</span> getattr(self._con, name)

    <span class="PY_KEYWORD">def</span> __del__(self):
        self.close()


<span class="PY_KEYWORD">class</span> PooledPg:
    <span class="PY_STRING">"""A very simple PostgreSQL connection pool.

    After you have created the connection pool,
    you can get connections using getConnection().

    """</span>

    version = __version__

    <span class="PY_KEYWORD">def</span> __init__(self, maxconnections, *args, **kwargs):
        <span class="PY_STRING">"""Set up the PostgreSQL connection pool.

        maxconnections: the number of connections cached in the pool
        args, kwargs: the parameters that shall be used to establish
            the PostgreSQL connections using pg.connect()

        """</span>
        <span class="PY_COMMENT"># Since there is no connection level safety, we</span>
        <span class="PY_COMMENT"># build the pool using the synchronized queue class</span>
        <span class="PY_COMMENT"># that implements all the required locking semantics.</span>
        <span class="PY_KEYWORD">from</span> Queue <span class="PY_KEYWORD">import</span> Queue
        self._queue = Queue(maxconnections)
        <span class="PY_COMMENT"># Establish all database connections (it would be better to</span>
        <span class="PY_COMMENT"># only establish a part of them now, and the rest on demand).</span>
        <span class="PY_KEYWORD">for</span> i <span class="PY_KEYWORD">in</span> range(maxconnections):
            self.cache(PgConnection(*args, **kwargs))

    <span class="PY_KEYWORD">def</span> cache(self, con):
        <span class="PY_STRING">"""Add or return a connection to the pool."""</span>
        self._queue.put(con)

    <span class="PY_KEYWORD">def</span> connection(self):
        <span class="PY_STRING">"""Get a connection from the pool."""</span>
        <span class="PY_KEYWORD">return</span> PooledPgConnection(self, self._queue.get())
</pre>
<!--footer-->

</body>
</html>
